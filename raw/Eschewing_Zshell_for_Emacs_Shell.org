#+TITLE: Eschewing_Zshell_for_Emacs_Shell
#+URL: http://www.howardism.org/Technical/Emacs/eshell-fun.html
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-30 二 14:21]
#+OPTIONS: ^:{}

我做到了. 我已经不再需要Zshell , Fish , Bash 等等这些东西了…至少大部分时候都不再需要了. 
它们都是很不错的工具,只不过我我的工作流是以编辑器来驱动的. 我启动Emacs,然后仅仅在需要管理文件之类的操作时才进入shell,而不是先进入shell四处游荡,然后再开始编辑文件.

大多数Emacs用户都会拆分Emacs window然后在Emacs中启动一个shell,并在需要时进入该shell window中进行操作,不需要时则切换到其他window.
不过我发现Emacs的eshll似乎更适合于我,我越用就越发的爱上它了.

不过eshell有一个问题就是缺少文档...而且还有点难以理解. 因此我才撰写了本文. 不过在我开始之前,我要给Mickey Petersen的新书《[[https://www.masteringemacs.org][Mastering Emacs]]》做个广告,它里面有一篇"[[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][mastering the eshell]]" 写得特别好(而且免费就能阅读).

* Why?

shell其实就是一个由命令驱动的REPL. 你输入命令然后查看结果,然后输入另一个命令…如此往复. 如果输出结果只有几行,你会让它直接输出,如果输出结果有几百行,你会通过管道将结果传递给less命令.

不过在eshell中,你根本无需将结果传递给另一个pager,如果你发现输出结果太多内容了,只需要按下 =C-c C-p= 就会帮你跳到最后输入命令的头部,and then C-v your way down. 甚至于,你可以直接搜索你想要的那部分内容.
在eshell中执行命令意味着,这些命令的输出都会经过Emacs pager的处理.

更酷的是,你可以像[[http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/][Plan 9]] 那样启用Eshell的智能显示功能, 这时,执行命令后,如果命令输出过长,你的光标会自动留在输入命令的位置,直到你输入了一个非光标移动的键,光标才会跳到输入下一条命令的地方.

Eshell拥有如下几个优点:

+ 它是由Emacs Lisp写成的, 因此它是跨平台的.
+ 你不仅仅可以使用脚本和程序,你还可以使用Emacs函数… 想用Lisp写你的shell脚本?没问题!
+ 它的使用体验也比一般的shell要好.

但是当一个程序想要直接操作终端时,就不适于Eshell了.^[[http://www.howardism.org/Technical/Emacs/eshell-fun.html#fn.1][1]]

你可能也尝试过Eshell, 我想你一定为它的独特性所吸引. 现在让我们更近一步的了解它…

* Starting the Shell

我的工作流是以Emacs所驱动的,偶尔才会用到shell. 我常常会在shell中输入一些命令后,然后回到原来的工作中. 当我想弹出一个shell时,我使用下列函数来创建一个指定buffer的window(该window位于原始window的下方,占三分之一的高度),并开启eshell(它会自动进入当前buffer的目录中).

#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)
#+END_SRC

下面是我自定义的函数 =x=, 它会退出shell并关闭该window.

#+BEGIN_SRC emacs-lisp
  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))
#+END_SRC

* Lisp REPL? Almost

EShell 同时也是一个 Lisp REPL. 下面是一些例子:

#+BEGIN_EXAMPLE
  $ (message "hello world")
  "hello world"
#+END_EXAMPLE

不过,在shell中,相比语法的清晰度我们更在意输入的简洁性与速度, 因此,在这种情况下,我们可以省略掉两边的括号:

#+BEGIN_EXAMPLE
  $ message "hello world"
  "hello world"
#+END_EXAMPLE

Functions that begin with eshell/ are available in Eshell without the prefix, so calling the eshell/echo
function makes the shell experience less surprising:

#+BEGIN_EXAMPLE
  $ echo "hello world"
  "hello world"
#+END_EXAMPLE

If you put it in parens, you need to give it the full name:

#+BEGIN_EXAMPLE
  $ (eshell/echo "hello world")
  "hello world"
#+END_EXAMPLE

What about types? In a normal shell, everything is a string, but EShell has a foot in both worlds:

#+BEGIN_EXAMPLE
  $ echo hello world
  ("hello" "world")
#+END_EXAMPLE

A list of two strings. However, you can NOT attempt to pass that echo to car… at least not directly:

#+BEGIN_EXAMPLE
  $ car echo hello world
#+END_EXAMPLE

Returns an error, as does:

#+BEGIN_EXAMPLE
  $ car (list hello world)
#+END_EXAMPLE

You see, once you bring in parens, you also bring in syntactic specific-ness, so you would need to do this:

#+BEGIN_EXAMPLE
  $ car (list "hello" "world")
#+END_EXAMPLE

EShell has a listify that converts its arguments to a list of strings:

#+BEGIN_EXAMPLE
  $ listify hello world
  ("hello" "world")
#+END_EXAMPLE

But if you want to pass that data to something like car, you need to surround it in curly braces, which is
EShell’s way of saying, call some shell-like-goodness, but return it like Lisp:

#+BEGIN_EXAMPLE
  $ car { listify hello world }
  hello
#+END_EXAMPLE

Not really sure what is the real difference between list and listify, as they seem to behave the same to me:

#+BEGIN_EXAMPLE
  $ listify hello world
  ("hello" "world")

  $ list hello world
  ("hello" "world")

  $ listify 1 2 3
  (1 2 3)

  $ list 1 2 3
  (1 2 3)

  $ list "hello world"
  (#("hello world" 0 11
     (escaped t)))

  $ listify "hello world"
  (#("hello world" 0 11
     (escaped t)))
#+END_EXAMPLE

I guess my point to this little exploration is that you can pretend it is a shell, and you can pretend it is a
Lisp REPL, and you have ways to weave between the two, but be a bit careful.

* Variables

As the documentation says,

#+BEGIN_QUOTE
    Since Eshell is just an Emacs REPL(1), it does not have its own scope, and simply stores variables the
    same you would in an Elisp program.
#+END_QUOTE
   
Running printenv only displays the environment variables:

#+BEGIN_EXAMPLE
  $ setenv A "hello world"
  $ getenv A
  "hello world"
#+END_EXAMPLE

Use the setq to assign normal, Emacs variables:

#+BEGIN_EXAMPLE
  $ setq B hello world
  $ echo $B
  hello
  $ setq B "hello world"
  $ echo $B
  hello world
#+END_EXAMPLE

Preface with a =$=, you can access any Emacs variable:

#+BEGIN_EXAMPLE
  $ echo $recentf-max-menu-items
  25
#+END_EXAMPLE

Keep in mind that environment variables over-shadow Emacs variables:

#+BEGIN_EXAMPLE
  $ setenv C hello
  $ setq C goodbye
  $ echo $C
  hello
#+END_EXAMPLE

Finally, you can source Eshell variables from a file:

#+BEGIN_EXAMPLE
  $ cat blah.eshell
  setq FOO 42
  setq BLING "bongy"

  $ . blah.eshell
  42
  bongy

  $ echo $FOO
  42

  $ echo $BLING
  bongy
#+END_EXAMPLE

* Loops

Executing a series of commands on each matching file is a standard use case for shells. While you could use a
Lisp-like dolist, EShell attempts to give you a similar shell-like syntax:

#+BEGIN_EXAMPLE
  $ for file in *.org {
    echo "Upcasing: $file"
    mv $file $file(:U)
  }
#+END_EXAMPLE

The (:U) converts the contents before it to upper case format. It is a modifier, and I’ll babble on about this
in the next section (since this is one of Eshell’s best feature).

I find it interesting to note that *.org gives the for loop a list to iterate over, but if there is more than
one argument, a list is created, as in:

#+BEGIN_EXAMPLE
  $ for i in 1 2 3 4 { echo $i }
#+END_EXAMPLE

Passing more than one list flattens them into one list, so the following works as you expect:

#+BEGIN_EXAMPLE
  $ for file in emacs* zsh* { ... }
#+END_EXAMPLE

* File Selection

If all you were doing was renaming a single file, or changing access permissions on all files in a directory,
you’d hardly need a flexible shell, as dired or even Finder is sufficient for those tasks. A shell comes in
handy when selecting a subset of files based on a pattern, and EShell really shines here, because of its
filters (that it stole from [[http://zsh.sourceforge.net/Doc/Release/Expansion.html][Zshell’s modifiers]]):

#+BEGIN_EXAMPLE
  $ ls -al *.mp3(U)   # Show songs I own
#+END_EXAMPLE

The *.mp3 part is just a normal globbing pattern we all know and love, but the (U) part further filters the
selection. In this case limiting the selection to files you own.

The help for this feature is available in the shell, so type the following:

#+BEGIN_EXAMPLE
  $ eshell-display-predicate-help
  $ eshell-display-modifier-help
#+END_EXAMPLE

While you may have seen the predicates before (since they are similar to ZShell’s), the coolest part is that
you can write some ELisp code to add your own predicates and modifiers.

** File Filter Predicates

Here is a list of the filter predicates. These can be stacked, so typing, ls **/*(IW) will display all the
files in the current directory (and sub-directories) that are readable by the group owner or all accounts on
the system.

| / | Directories (may accept d … gotta verify that)          |
| . | Regular files                                            |
| * | Executable files                                         |
| @ | Symlinks                                                 |
| p | named pipes                                              |
| s | sockets                                                  |
| U | Owned by current UID                                     |
| u | Owned by the given user account or UID, e.g. (u'howard') |
| g | Owned by the given group account or GID, e.g. (g100)     |
| r | Readable by owner (A is readable by group)               |
| R | Readable by World                                        |
| w | Writable by owner (I is writable by group)               |
| W | Writable by World                                        |
| x | Executable by owner (E is executable by group)           |
| X | Executable by world                                      |
| s | setuid (for user)                                        |
| S | setgid (for group)                                       |
| t | Sticky bit                                               |
| % | Other file types.                                        |

These are fairly straight-forward. For example, list all the directories:

#+BEGIN_EXAMPLE
  ls -ld *(/)
#+END_EXAMPLE

Some symbols take options, like to list all files owned by the howard account, specify the string with single
quotes:

#+BEGIN_EXAMPLE
  ls -ld *(u'howard')
#+END_EXAMPLE

The % requires a second parameter to specify the file type to filter. These are taken from the ls, so %c will
display char devices. Here is the list if stole from the ls man page:

| b | Block special file     |
| c | Character special file |
| d | Directory              |
| l | Symbolic link          |
| s | Socket link            |
| p | FIFO                   |

The options can be combined. For instance, list all symbolic links owned by your account:

#+BEGIN_EXAMPLE
  ls -l *(@U)
#+END_EXAMPLE

Or, list all symbolic links that you don’t own by prefixing the ^ symbol:

#+BEGIN_EXAMPLE
  ls -l *(@^U)
#+END_EXAMPLE

Gets more interesting with time and size filters which take parameters. This is the cheat-sheet-like output
from eshell-display-predicate-help:

#+BEGIN_QUOTE
a[Mwhms][+-](N|'FILE')
    access time +/-/= N months/weeks/hours/mins/secs (days if unspecified) if FILE specified, use as
    comparison basis; so a+’file.c’ shows files accessed before file.c was last accessed.
m[Mwhms][+-](N|'FILE')
    modification time…
c[Mwhms][+-](N|'FILE')
    change time…
L[kmp][+-]N
    file size +/-/= N Kb/Mb/blocks
#+END_QUOTE

The following examples should clarify how to use these:

To display all org-mode files in my directory that I’ve modified since yesterday, I would type:

#+BEGIN_EXAMPLE
  ls *.org(m-1)
#+END_EXAMPLE

Where the m is the modification time, the - means less than and 1 refers to the day, since we didn’t specify
any other time period. To display the files we’ve modified over the last 8 hours, we’d enter:

#+BEGIN_EXAMPLE
  ls *.org(mh-8)
#+END_EXAMPLE

Compress everything which hasn’t been accessed in 30 days:

#+BEGIN_EXAMPLE
  bzip2 -9v **/*(a+30)
#+END_EXAMPLE

The ** symbol is recursive access to sub-directories.

Shell scripts (that end with a .sh and are executable (we specify the * character first) that are 50k or
larger (we use the + symbol):

#+BEGIN_EXAMPLE
  ls ***/*.sh(*Kl+50)
#+END_EXAMPLE

To specify 50K, we first write k then + (to mean or larger) and finally the size. The three stars, *** is a
recursive search into sub-directories, but not to follow symbolic links.

** Modifiers

Modifiers are similar to filters mentioned above, except that begin with a colon symbol, and they change the
string, file or list that precedes it. For instance, :U upper-cases a string or file name:

#+BEGIN_EXAMPLE
  for f in *(:U) { echo $f }
#+END_EXAMPLE

Returns:

#+BEGIN_EXAMPLE
  AB-TESTING-EXPERIMENTS.ORG
  AB-TESTING-PRESENTATION.ORG
  ACTIONSCRIPT-NOTES.ORG
  ADIUM-PLUGINS-AND-EXTENSIONS.ORG
  ALFRED.ORG
  ANGULARJS-BOILERPLATE.ORG
  ANGULARJS-MODULES.ORG
  ANGULARJS-TESTING.ORG
  APPLESCRIPT-RECIPES.ORG
  APPLESCRIPT-SKYPE.ORG
  ...
#+END_EXAMPLE

The modifiers can also affect a variable. The following example behaves the same as the previous example:

#+BEGIN_EXAMPLE
  for f in * { echo $f(:U) }
#+END_EXAMPLE

Here is the complete list of modifiers for an individual string or file name:

#+BEGIN_EXAMPLE
  :L      lowercase                                
  :U      uppercase                                
  :C      capitalize                               
  :h      dirname                                  
  :t      basename                                 
  :e      file extension                           
  :r      strip file extension                     
  :q      escape special characters                
  :S      split string at any whitespace character 
  :S/PAT/ split string at each occurrence of /PAT/ 
  :E      evaluate again                           
#+END_EXAMPLE

Here is the list of modifiers for a list:

#+BEGIN_EXAMPLE
  :o            sort alphabetically                           
  :O            reverse sort alphabetically                   
  :u            unique list (typically used after :o or :O)   
  :R            reverse the list                              
  :j            join list members, separated by a space       
  :j/PAT/       join list members, separated by PAT           
  :i/PAT/       exclude all members not matching PAT          
  :x/PAT/       exclude all members matching PAT              
  :s/pat/match/ substitute PAT with MATCH                     
  :g/pat/match/ substitute PAT with MATCH for all occurrences 
#+END_EXAMPLE

To append the string, -foobar, to all files owned by you, before the extension, you would type:

#+BEGIN_EXAMPLE
  for F in *(U) { mv $F $F(:r)-foobar.$F(:e) }
#+END_EXAMPLE

** Custom Filter Predicates

As you know, the best part of Emacs is its ability to customize everything…including your shell experience.

As [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell#adding-new-modifiers-and-predicates][Mickey Petersen mentions]], we can create our own predicates to filter out files. Wouldn’t it be nice if we
could specify files based on their internal org-mode #+TAGS entry. For instance, at the top of my files, I add
the following headers:

#+BEGIN_SRC org
  ,#+TITLE:  Alfred
  ,#+AUTHOR: Howard Abrams
  ,#+DATE:   [2013-05-15 Wed]
  ,#+TAGS:   mac technical
#+END_SRC

I would like Eshell to be able to list files that end in org, but with contents that include the mac tag,
like:

#+BEGIN_EXAMPLE
  ls *.org(T'mac')
#+END_EXAMPLE

If the filter used a single symbol, we would append a tuple to eshell-predicate-alist that specifies the
symbol and the predicate function (that returns true or nil). Something like

#+BEGIN_SRC emacs-lisp
  (add-to-list 'eshell-predicate-alist '(?P . eshell-primary-file))
#+END_SRC

However, in our example, the T symbol takes the tag as a parameter. In this case, we need a two-step process:

 1. A function to parse the Eshell buffer to look for the parameter (and move the point past the parameter)
 2. A predicate function that takes a file as a parameter

For the first step, we have our function called as it helps parse the text at this time. Based on what it
sees, it returns the predicate function used to filter the files:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'eshell-predicate-alist '(?T . (eshell-org-file-tags)))
#+END_SRC

I combine the two steps into a single function, as after the function is done with Step 1, we will return a
lambda expression for Step 2.

The first step is to parse the text following the point looking for the tag (surround in single quotes), and
move the point forward over the option for our filter function (notice the goto-char to the end of the match).

#+BEGIN_SRC emacs-lisp
  (defun eshell-org-file-tags ()
    "Helps the eshell parse the text the point is currently on,
  looking for parameters surrounded in single quotes. Returns a
  function that takes a FILE and returns nil if the file given to
  it doesn't contain the org-mode #+TAGS: entry specified."

    ;; Step 1. Parse the eshell buffer for our tag between quotes
    ;;         Make sure to move point to the end of the match:
    (if (looking-at "'\\([^)']+\\)'")
        (let* ((tag (match-string 1))
               (reg (concat "^#\\+TAGS:.* " tag "\\b")))
          (goto-char (match-end 0))

          ;; Step 2. Return the predicate function:
          ;;         Careful when accessing the `reg' variable.
          `(lambda (file)
             (with-temp-buffer
               (insert-file-contents file)
               (re-search-forward ,reg nil t 1))))
      (error "The `T' predicate takes an org-mode tag value in single quotes.")))
#+END_SRC

The returned function loads the given file into a temp-buffer, and search the contents for the regular
expression. Returns nil if the match wasn’t found (false), and anything else is interpreted as true.

Now I can search for Homebrew commands without bringing up my beer notes:

#+BEGIN_EXAMPLE
  $ grep brew *.org(T'mac')
#+END_EXAMPLE

Since the grep is really the Emacs grep function, it brings the results up in a buffer that I can click to
load/edit.

* Summary

Of course the real beauty of EShell is the Emacs integration, for instance, using highlight-regexp to colorize
key words from expected output, or piping the results to an Emacs buffer:

#+BEGIN_EXAMPLE
  $ ls -al > #<buffer some-notes.org>
#+END_EXAMPLE

And then issue a C-c | on that results to create an org-mode table you can continue to manipulate.

While the Eshell is baked into Emacs, and requires no customization, I have [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][made a few improvements]] that may
be helpful to others.

* Footnotes:

^[[http://www.howardism.org/Technical/Emacs/eshell-fun.html#fnr.1][1]]

Programs like top wouldn’t work well in Eshell since it these programs are still attempting to manipulate the
world with ancient VT100 control codes, and the Eshell mostly is expecting standard textual output.

However, if you type top, eshell notices top on its naughty list (actually, the list is called
eshell-visual-commands), and will farm it out to a special comint buffer.

In practice, I don’t notice this limitation, since most applications I would like, I usually just use a
similar program re-written in Emacs. However, if you find an app that doesn’t work well in EShell, append it
to this list.
