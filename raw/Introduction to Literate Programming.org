#+TITLE: Introduction to Literate Programming
#+URL: http://howardism.org/Technical/Emacs/literate-programming-tutorial.html                              
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-06-23 四 17:59]
#+OPTIONS: ^:{}

欢迎来到文学编程的世界! 本文会简单介绍一下如何使用org-mode进行文学编程

本文的内容来源于PDX Emacs Hackers举办的研讨会, 但是考虑到很少人能够现场参加该研讨会,因此我决定把它写成一片指南. 我假设你已经有了一定的[[http://howardism.org/Technical/Emacs/getting-started.html][Emacs基础]] 并且对[[http://howardism.org/Technical/Emacs/learning-org-mode.html][org-mode也比较熟悉]] ,至少知道如何导出文档.

众所周知,Org的功能太多了, 它具有在一个文档中编写,执行和连接代码块的能力,这种能力 are extensive, 要把这些功能都写成文档是件让人感觉恐怖的任务. 我希望这份指南能开个好头, 若你发现我遗漏了什么,请[[http://howardism.org/formmail/mail?to=howardism][告之]].

*警告* :下面的例子都写得很蹩脚.

* 必要条件

本文基于[[http://orgmode.org][org-mode]] v8.2.10(或更新). 由于Emacs已经内置了org, 你需要通过 =C-h v <RET> org-version= 来看所使用的org是否符合要求,以保障本指南例子能够正确运行(大多数的例子应该没问题,但是也不好说…).

若你的org版本太旧,请运行下面这段代码:

#+BEGIN_SRC emacs-lisp
  (when (>= emacs-major-version 24)
    (require 'package)
    (add-to-list 'package-archives
                 '("org" . "http://orgmode.org/elpa/")
                 t)
    (package-initialize)
    (package-refresh-contents)
    (package-install "org"))
#+END_SRC

That should do it. 你还需要安装 [[http://orgmode.org/worg/org-contrib/][org-plus-contrib]].

在这篇指南中,我会向你展示多种语言的接口,但这也意味着你需要在本地安装大量的解释器,你至少需要安装下面几个解释器:

+ Shell (很抱歉,对于Windows用户来说,这一点恐怕比较难实现)
+ Python
+ Ruby

当然,你是个聪明人,把这些例子修改成你所使用的语言应该是很容易的.

* 背景知识

在我们开始学习使用[[http://orgmode.org][org-mode]] 进行文学编程之前,我先简单介绍一下文学编程吧.

** 为什么使用文学编程?

文学编程最初是由Donald Knuth于20世纪80年代提出来的,旨在加强团队成员中的交流. 如[[http://www.brainyquote.com/quotes/authors/d/donald_knuth.html#0RwBBIoWjqiKPb2Y.99][Donald Knuth]] 所说过的

#+BEGIN_QUOTE
让我们改变针对程序结构的传统看法吧. 不要把我们的任务看成是像计算机描述怎么去作,而是向其他人解释我们想让计算机做什么.
#+END_QUOTE
   
文学编程希望能做到写得程序适于人阅读,文档描述能遵循问题逻辑的顺序,同时不受制于编程语言的缺陷. 下面是一份文学编程的例子,对人来说,这是份可阅读的文档,同时它还是源代码文件:

[[http://howardism.org/Technical/Emacs/literate-programming-tangling.png]]

其背后的思想是反转注释与代码之间的关系,以前是代码中点缀着些注释,现在则是在文档中内嵌一些代码.

由于从文学编程文档中抽取出来的源代码与直接编写的源代码无异,因此这一做法并不需要现有的编程环境做出什么改变.(although it is used, to various degrees, in niche circles).

* 为什么使用Org?

Knuth最开始认为文学编程只需要使用最简单功能的编辑器就行, as he only wrote the noweb program to create (weave) the documentation and write (tangle) the source code.

依我的观点,文学编程必须依赖编辑器的帮助,[[http://ipython.org/notebook.html][iPython’s notebook]]就是个例子. 但是我认为文档内容应该以可读文本的方式存储,而不是存储为JSON格式的文件. 就像 [[http://transcriptvids.com/v/oJTwQvgfgMM.html][Carsten Dominik]] 说过的:

#+BEGIN_QUOTE
在第三个千禧年,使用文本文件是否还有意义? 文本文件是唯一真正可以说是可移植的文件格式. 用文本文件保存的数据永远不会丢失.
#+END_QUOTE
   
因此若你想进行文学编程,org-mode是个很好的选择,更何况我们本来就已经在用org-mode作许多事情了, 对吧?

* 使用Org有什么优势?

使用org-mode进行文学编程有如下几点优势:

+ 代码更易理解
+ 方便团队讨论问题
+ 针对复杂状况更容易思考的清晰一点
+ 学习新库和API时,可以一边实验一边记笔记
+ 可以同时使用多种语言,每种语言只完成自己擅长的任务(例如可以使用通用语言来查询,维护数据库)
+ org具有组织化的能力,它提供了类似Agenda和task这类的工具
  
* 警告
:PROPERTIES:
:ID:       o7ij1vw0w9h0
:END:

1980年的软件世界与今天的情况相比,已经发生了翻天覆地的改变. 现在的工程师们连接的更紧密了,且常常以团队的形式进行工作. 虽然如此,但各个工程师所使用的工具还是各不相同的. 即使你的团队并不使用Emacs, 你依然会觉得org-mode的方法很有用处.

首先,org-mode很适合用于设计复杂算法,当你有什么灵感的时候,可以立即写下最终的代码(你所写下的记录会成为代码中的注释), 当你毫无进展时,你可以直接把记录发给团队中的其他人敬候回应.

其次,org-mode文件可以被认为是一个repl环境,因为其中的每个代码块都能被分别执行,并且代码块的执行结果还能传递给其他的代码块… but I’m getting a head of myself.

* 导出文档

使用org-mode的主要原因是可以将org文件导出成HTML,电子邮件信息,Wiki等许多格式的文档. Org特别适合于写科技类的文章,我主要用它来程序代码相关的东西.

org-mode还支持LaTex,下面是个例子:

#+BEGIN_SRC org
  - Unicode References :: for instance, \alpha, \beta and \gamma.
  - Subscripts :: like Hydrogen atoms, H_2, and Water, H_{2}O.
  - Superscripts :: The mass of the sun is 1.989 x 10^30 kg.
  - Embedded Equations :: Surrounded with either single =$=, like $a^2=b$,
  or escaped parenthesis, like: \( b=\frac{1}{2} \)
  - Separated equations :: Either in double =$$= or escaped brackets, like
  this: $$ a=\frac{1}{2}\sqrt{2} $$ or this: \[ a=-\sqrt{2} \] or this:
  \begin{equation}
  x=\sqrt{b}
  \end{equation}

  ,#+OPTIONS: tex:t
#+END_SRC

上面那段内容可以转换成下面的HTML展示:

#+BEGIN_SRC text
  Unicode References
      for instance, α, β and γ.
  Subscripts
      like Hydrogen atoms, H[2], and Water, H[2]O.
  Superscripts
      The mass of the sun is 1.989 x 10^30 kg.
  Embedded Equations
      Surrounded with either single $, like \(a^2=b\), or escaped parenthesis, like: \( b=\frac{1}{2} \)
  Separated equations
   
      Either in double $$ or escaped brackets, like this: \[ a=\frac{1}{2}\sqrt{2} \] or this: \[ a=-\sqrt{2} \]
      or this:
   
      \begin{equation} x=\sqrt{b} \end{equation}
#+END_SRC

* 基础知识

这篇指南来源于一场研讨会, 那么让我们运行Emacs,创建一个org-mode文件,然后开始操作.

让我们输入以下代码块(大小写无关):

#+BEGIN_SRC org
  ,#+BEGIN_SRC emacs-lisp
    (directory-files ".")
  ,#+END_SRC
#+END_SRC

+ 按下 =C-c C-c= 会执行该命令,并且将结果插入到文件后面 … we’ll use that to our advantage later.
+ 按下 =C-c '(单引号)= 可以以指定语言的mode来编辑这段代码. 这样你就可以利用 =paredit= 或者类似的插件来帮你编辑代码了.

注意: 发现我的例子有错误后(注意,我并没有说"如果"), 去查一下 [[http://orgmode.org/org.html#toc_Working-with-source-code][the org-mode manual]],然后将勘误发给我.

** 快捷方式

若你使用比较新版本的Emacs(新于v22)或这时比较新版本的org-mode(你可能直接从ELPA中安装),那么你可以使用 [[http://orgmode.org/org.html#Easy-templates][Org Templates]],它提供了如下功能:

+ 输入 =<s <TAB>= 可以快速创建一个代码块
+ 如果没有创建代码块,或许你可以试试 [[https://github.com/capitaomorte/yasnippet][yasnippets]]
+ 从代码块的 =BEGIN= 到 =END= 部分的任意位置,你都可以通过按下 =C-c C-c= 来执行代码
+ 使用 =C-c M-f= 跳转到文件中下一个代码块位置,使用 =C-c M-b= 跳转到上一个代码块位置

** 推荐配置

要想语法高亮代码块中的代码,可以将下面代码放到 =.emacs= 初始化文件中:

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
#+END_SRC

将 =org-confirm-babel-evalute= 设置为nil,可以在你用 =C-c C-c= 执行代码块时,不再提示“Do you want to execute”

* 支持的语言

Org-mode[[http://orgmode.org/org.html#Languages][支持许多的编程语言]], 但还是有些语言是不支持的(当然,你可以为Org-mode添加新语言的支持,这并不难). 

我会展示一些比较流行的语言案例,从中你也可以看出不同语言之间的些许差别.

** Ruby案例

让我们将上面lisp的例子修改为Ruby:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby
    Dir.entries('.')
  ,#+END_SRC
#+END_SRC

你再按下 =C-c C-c= 发现没有反映, 这是因为你需要预先加载好Ruby语言的支持: =M-x load-library <RET> ob-ruby=

你也可以将下面配置放到 =.emacs= 中:

#+BEGIN_SRC emacs-lisp
  (require 'ob-ruby)
#+END_SRC

** Python案例

需要注意的是,Ruby和Lisp类似,会自动将最后表达式的值作为代码块的返回值. 然而,Python语言,需要明确的 =return= 语句:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python
    from os import listdir
    return listdir(".")
  ,#+END_SRC
#+END_SRC

** shell案例

大多数的语言使用返回值作为结果,然而shell语言使用输出到标准输入的内容作为结果:

#+BEGIN_SRC emacs-lisp
  ,#+BEGIN_SRC sh
  ls -1
  ,#+END_SRC
#+END_SRC

若按下 =C-c C-c= 没反映,你需要执行: =M-x load-library <RET> ob-sh=

** 其他语言

若你像我一样,是个多语言开发者,你可以添加类似下面的配置到 =.emacs= 文件中:

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sh         . t)
     (js         . t)
     (emacs-lisp . t)
     (perl       . t)
     (scala      . t)
     (clojure    . t)
     (python     . t)
     (ruby       . t)
     (dot        . t)
     (css        . t)
     (plantuml   . t)))
#+END_SRC

* 代码块设置

通过设置不同的代码块参数(也称为"头参数")可以产生各种有趣的结果. 代码块可以有0个或多个头参数.

First let’s dive into the various ways they can be defined, and then discuss most of the specific parameters
after, but I need a parameter we can use.

** Example: dir

As an example of how to set a parameter, let’s look at the [[http://orgmode.org/org.html#dir][dir]] parameter, which sets the directory/folder for
where a code block executes:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh :dir /etc
    ls
  ,#+END_SRC
#+END_SRC

Type C-c C-c to execute this, and you’ll notice a lot more entries in that directory… assuming, of course, you
have a /etc directory.

An interesting aspect of this parameter is when you use Tramp references to have code block remotely executed:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh
    hostname -f
  ,#+END_SRC

  ,#+RESULTS:
  : blobfish

  ,#+BEGIN_SRC sh :dir /howardabrams.com:
    hostname -f
  ,#+END_SRC

  ,#+RESULTS:
  : goblin.howardabrams.com
#+END_SRC

** Setting Parameter Locations

Parameters can be set in different locations. Here is the list from most specific to most general:

  * Inline with Header Block, or above Header Block
  * Defaults for Blocks in a Section
  * Defaults for Blocks in entire Document
  * Defaults for Every Document

Having a particular parameter set for all documents isn’t very useful to me, but this can be done by setting
either of these list variables:

  * org-babel-default-header-args
  * org-babel-default-header-args:<lang>

Note: You can set parameters when a block is called, but we’ll talk about this later.

** Too Many Parameters?

Setting parameters inline with Header Block is fine with few parameters, but org-mode supplies lots of
parameters, and if you have too many, you can bring one or more up above block. For instance, the following
are equivalent:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh :dir /etc :var USER="howard"
    grep $USER passwd
  ,#+END_SRC

  ,#+HEADER: :dir /etc
  ,#+BEGIN_SRC sh :var USER="howard"
    grep $USER passwd
  ,#+END_SRC

  ,#+HEADER: :dir /etc
  ,#+HEADER: :var USER="howard"
  ,#+BEGIN_SRC sh
    grep $USER passwd
  ,#+END_SRC
#+END_SRC

** Section Default Parameters

Parameters that should be the same for all source blocks in a section can be placed in a property drawer.
Perhaps, you should just run through this on your own by following these steps:

  * Create a header section in your org file
  * Type: C-c C-x p
  * For Property enter: dir
  * For Value enter: /etc

Jump to the :PROPERTIES: drawer, and hit TAB to see the contents, but it should look something like:

#+BEGIN_SRC org
  ,* A New Section
  :PROPERTIES:
  :dir: /etc
  :END:

  ,#+BEGIN_SRC ruby
    File.absolute_path(".")
  ,#+END_SRC

  ,#+RESULTS:
  : /etc
#+END_SRC

** Language-Specific Default Values

You can specify [[http://orgmode.org/org.html#Language-specific%2520header%2520arguments%2520in%2520Org%2520mode%2520properties][language-specific header arguments]]. Try the following:

  * Type: C-c C-x p
  * For Property enter: header-args:sh
  * For Value enter: :dir /etc
  * Type: C-c C-x p
  * For Property enter: header-args:ruby
  * For Value enter: :dir /

You should have something that looks like:

#+BEGIN_SRC org
  ,* Another Section
  :PROPERTIES:
  :header-args:sh: :dir /etc
  :header-args:ruby: :dir /
  :END:

  ,#+BEGIN_SRC sh
    ls -d $(pwd)
  ,#+END_SRC

  ,#+RESULTS:
  : /etc

  ,#+BEGIN_SRC ruby
    File.absolute_path('.')
  ,#+END_SRC

  ,#+RESULTS:
  : /
#+END_SRC

Note: Some parameters can only be set with header-args.

** Default Parameters for Document

To set a parameter for all blocks in a document, use the #+PROPERTY: setting placed somewhere in your
document.

#+BEGIN_SRC org
  ,#+PROPERTY:    dir ~/Work
#+END_SRC

Notice these parameters do not have initial colon.

Language specific ones, however, do:

#+BEGIN_SRC org
  ,#+PROPERTY:    header-args:sh  :tangle no
#+END_SRC

Note: They aren’t registered until you hit C-c C-c on them.

* Header Parameter Types

With the basics in place, the rest of this tutorial describes the source block controls done by parameter
settings. I’ve separated and organized these based on its usage:

+ Evaluation Parameters :: like dir, affects how a block is executed
+ Export Parameters :: affects how a block or the results from execution is shown when it is exported to HTML
+ Literate Programming Parameters :: connecting blocks together to change the actual source code
+ Variable Parameters :: variables for a source block can be set in various ways
+ Miscellaneous Input/Output :: of course, you have to have a collection of parameters that don’t fit elsewhere

* Evaluation Parameters

The following parameters affect how a block is evaluated.

** Results

When you execute a block, what do you want out of it?

  * results of the expression?
  * outputted results?

Let’s look at this Ruby block. By default, you will get the results of the last expression:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby
      puts 'Hello World'
      5 * 6
  ,#+END_SRC

  ,#+RESULTS:
  : 30
#+END_SRC

Change the [[http://orgmode.org/org.html#Results%2520of%2520evaluation][:results]] header argument to be output, and you’ll get everything that was printed:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby :results output
      puts 'Hello World'
      5 * 6
  ,#+END_SRC

  ,#+RESULTS:
  : Hello World
#+END_SRC

Note: Default for sh is output.

** Output Formatting

Results of code evaluation are re-inserted into your document.

+ table :: Row for single array, full table for array of arrays
+ list :: Regular org-mode list exported as an un-ordered list
+ verbatim :: Raw output
+ file :: Writes the results to a file
+ html :: Assumes the output is HTML code, and that is what is exported
+ code :: Assumes output is source code in the same language
+ silent :: Only shown in the mini-buffer

The reasons for this variety is that the results can be exported (as in HTML, Email), as well as can help how
the results are used as input variables to other code blocks. Yeah, that is really the most interesting stuff,
but I need to save that for later in this document.

*** Lists

Notice the previous output created a table. Let’s make a list:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby :results list
    Dir.entries('.').sort.select do |file|
       file[0] != '.'
    end
  ,#+END_SRC

  ,#+RESULTS:
  - for-the-host.el
  - instructions.org
  - literate-programming-tangling.png
  - literate-programming-tangling2.png
#+END_SRC

The Ruby code above is just an example. Use your favorite language to pull out a list of files from a
directory.

*** Raw Output

Shell commands and log output are good candidates for raw output, for example:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh :results verbatim :exports both
    ssh -v goblin.howardabrams.com ls mossandcrow
  ,#+END_SRC

  ,#+RESULTS:
  OpenSSH_6.6.1, OpenSSL 1.0.1f 6 Jan 2014
  debug1: Reading configuration data /etc/ssh/ssh_config
  debug1: /etc/ssh/ssh_config line 19: Applying options for *
  debug1: Connecting to goblin.howardabrams.com [162.243.135.186] port 22.
  debug1: Connection established.
  debug1: identity file /home/howard/.ssh/id_rsa type 1
  debug1: identity file /home/howard/.ssh/id_rsa-cert type -1
  ...
#+END_SRC

*** Session

Each block re-starts its interpreter every time you evaluate a block. Use the [[http://orgmode.org/org.html#session][:session]] header parameter as a
label and have all blocks with that label use the same session. Why? Some issues with restarting your session
include:

  * Large start-up time with large REPLs … like Clojure
  * Large start-up time on remote machines using Tramp
  * Maintaining functions and other state between blocks

Note: Values can be passed between code blocks, so this last feature isn’t necessary.

To show that interpreters are restarted with each block:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python
    avar = 42
    return avar
  ,#+END_SRC

  ,#+RESULTS:
  : 42

  ,#+BEGIN_SRC python
    return avar / 2
  ,#+END_SRC

  ,#+RESULTS:
  NameError: global name 'avar' is not defined
#+END_SRC

To prove that :session-based interpreters are not restarted with each block:

#+BEGIN_SRC ruby :session foobar
  avar = 42
#+END_SRC

#+RESULTS:
: 42

#+BEGIN_SRC ruby :session foobar
  avar / 2
#+END_SRC

#+RESULTS:
: 21

The :session is good to set as a section property. Also note that you can switch to the *foobar* buffer to
interact with the interpreter, set variables and other state before evaluating the code block.

What’s wrong with the following?

#+BEGIN_SRC org
  ,* Confusing Stuff
  :PROPERTIES:
  :session:  stateful
  :END:

  ,#+BEGIN_SRC sh :results silent
    NUM_USERS=$(grep 'bash' /etc/passwd | wc -l --)
  ,#+END_SRC

  We have access to them:
  ,#+BEGIN_SRC sh
    echo $NUM_USERS
  ,#+END_SRC

  ,#+RESULTS:
  : 2

  This doesn't return... why?
  ,#+BEGIN_SRC ruby
    21 * 2
  ,#+END_SRC
#+END_SRC

*Warning*: A :session setting for a section is shared for each block… regardless of language! Probably not what
you want.

** Writing Results to a File

Create and evaluate this block:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby :results output :file primes.txt
    require 'prime'
    Prime.each(5000) do |prime|
      p prime
    end
  ,#+END_SRC
#+END_SRC

Notice that the results of evaluation is a link to a file. Click on the link to load the file in a buffer.

Note: The :file parameter needs :results output As it doesn't know how to format internal values

** Exporting

Hit C-c C-e h o to display your file in a browser.

The [[http://orgmode.org/org.html#exports][:exports]] header argument specifies what to export:

  * code for just the block
  * results for just the results to evaluating block
  * both for both code and results
  * none to ignore the block

Note: The :exports is good to set as a document property.

To get syntax highlight for HTML exports, simply include the [[https://www.emacswiki.org/emacs/Htmlize][htmlize]] library:

#+BEGIN_SRC emacs-lisp
  (require 'htmlize)
#+END_SRC

Should come with recent versions of org-mode. Doesn’t load? Install it from ELPA.

* Literate Programming

Some programming is useful in creating source code files from an org-mode file (called tangling).

** Tangling

The :tangle parameter takes all blocks of the same language, and writes them into the source file specified.

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby :tangle double-space.rb
    while s = gets
      print s ; puts
    end
  ,#+END_SRC
#+END_SRC

Type: C-c C-v t to render [[http://howardism.org/Technical/Emacs/double-space.rb][double-space.rb]]

Multiple code blocks with the same value are all included in the same file in order. With a :tangle parameter
value of yes, writes the block(s) to a file with same name as org file.

Use PROPERTY to specify values for the entire file:

#+BEGIN_SRC org
  ,#+PROPERTY:    tangle ~/.emacs.d/elisp/bling-mode.el
#+END_SRC

* Comments

If sharing source with others, have prose turned into [[http://orgmode.org/org.html#comments][comments]]:

#+BEGIN_SRC org
  Precede each line in the text from standard in (or file) with the 
  current line number. 
  See [[http://benoithamelin.tumblr.com/ruby1line][one liners]].

  ,#+BEGIN_SRC ruby
    while s = gets
      puts "#{$<.file.lineno}: #{s}"
    end
  ,#+END_SRC

  ,#+PROPERTY: tangle lineno.rb
  ,#+PROPERTY: comments org
#+END_SRC

Gets turned into this Ruby script:

#+BEGIN_SRC ruby
  # Precede each line in the text from standard in (or file) with the
  # current line number.
  # See [[http://benoithamelin.tumblr.com/ruby1line][one liners]].

  while s = gets
    puts "#{$<.file.lineno}: #{s}"
  end
#+END_SRC

The [[http://orgmode.org/manual/comments.html#comments][:comments]] parameter states how (and if) the prose should be inserted as comments. The org value specifies
that the output should just be the prose formatted as org code. Note: Only prose above a block is written out
as a comment.

If you change the value to the :dir parameter to link, you end up with a link to the original org-mode file.
Since most of my literate code, like my [[https://github.com/howardabrams/dot-files][.emacs files]], is the only thing I see (I often never look at the
generated source code), I haven’t found this helpful.

The default, is no, which doesn’t make any comments from the prose.

** Shebang

When creating scripts, we often need to give it the initial interpreter to use. Here is specify the [[http://orgmode.org/org.html#shebang][:shebang]]
parameter (either as a block header or a document property):

#+BEGIN_SRC org
  Precede each line in the text from standard in (or file) with the
  current line number.
  See [[http://benoithamelin.tumblr.com/ruby1line][one liners]].

  ,#+BEGIN_SRC ruby :shebang "#!/usr/local/bin/ruby"
    while s = gets
      puts "#{$<.file.lineno}: #{s}"
    end
  ,#+END_SRC

  ,#+PROPERTY: shebang #!/bin/ruby
  ,#+PROPERTY: tangle lineno
  ,#+PROPERTY: comments org
#+END_SRC

Works as expected:

#+BEGIN_SRC ruby
  #!/usr/local/bin/ruby
  # Precede each line in the text from standard in (or file) with the
  # current line number.
  # See [[http://benoithamelin.tumblr.com/ruby1line][one liners]].

  while s = gets
    puts "#{$<.file.lineno}: #{s}"
  end
#+END_SRC

** Noweb

If you name a block, you can include that block inside another block… as text, using [[http://orgmode.org/org.html#noweb][:noweb]]^[[http://howardism.org/Technical/Emacs/literate-programming-tutorial.html#fn.1][1]]. Consider this
org-mode file:

#+BEGIN_SRC org
  Print the last field of each line.

  ,#+NAME: the-script
  ,#+BEGIN_SRC ruby
    puts $F.last
  ,#+END_SRC

  ,#+BEGIN_SRC sh :noweb yes :tangle last-col.sh
    ruby -ane '<<the-script>>'
  ,#+END_SRC
#+END_SRC

Creates last-col.sh source code that contains:

#+BEGIN_SRC sh
  ruby -ane 'puts $F.last'
#+END_SRC

How useful is this?

Older languages that Donald Knuth used, required all variables and functions to be defined before used. This
meant, you always wrote code, bottom-up. However, some code may be better explained from a top-down approach.
The web and tangling approach could work well for some algorithms.

** Warning about Noweb

Suppose we had a block with multiple lines, as in:

#+BEGIN_SRC org
  ,#+NAME: prime
  ,#+BEGIN_SRC ruby
    require "prime"
    Prime.prime?(ARG[0])
  ,#+END_SRC

  ,#+BEGIN_SRC ruby :noweb yes :tangle primes.sh
    cat $* | xargs ruby -ne '<<prime>>'
  ,#+END_SRC
#+END_SRC

Treats the preceding text before the noweb reference like initial comment characters, as it will generate the
following:

#+BEGIN_SRC sh
  cat $* | xargs ruby -ne 'require "prime"
  cat $* | xargs ruby -ne 'Prime.prime?(ARG[0])'
#+END_SRC

This requires either [[http://ss64.com/bash/syntax-here.html][here docs]] or single quotes in a shell, or triple quotes in Python:

#+BEGIN_SRC sh
  cat $* | xargs ruby -ne '
  '
#+END_SRC

* Variables

Org can pass in one or move values into your source block as variables. This begin with an example where the
variable is statically set:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python :var interest=13
    return 313 * (interest / 100.0)
  ,#+END_SRC

  ,#+RESULTS:
  : 40.69
#+END_SRC

Of course, you can specify multiple variables, in one or more places, as in this example:

#+BEGIN_SRC org
  ,#+HEADER: :var a=42 d=56 :var f=23
  ,#+HEADERS: :var b=79 e=79
  ,#+BEGIN_SRC ruby :var c=3 g=2
    [ a, b, c, d, e, f, g ]
  ,#+END_SRC

  ,#+RESULTS:
  | 42 | 79 | 3 | 56 | 79 | 23 | 2 |
#+END_SRC

But how useful is there in setting static values for a variable?

** Block-to-Block Value Passing

Following along by creating a source block with a name, as in:

#+BEGIN_SRC org
  ,#+NAME: twelve-primes
  ,#+BEGIN_SRC ruby
    require 'prime'
    Prime.first 12
  ,#+END_SRC

  ,#+RESULTS: twelve-primes
  | 2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 |
#+END_SRC

Notice the RESULTS: section has the same name as the block. We can pass this result into another code block as
an array variable:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python :var primes=twelve-primes
    return primes[-1]
  ,#+END_SRC

  ,#+RESULTS:
  : 37
#+END_SRC

Perhaps this is the first time Ruby and Python have worked together.

** Tabular Variable Data

For this next example, I need a table of interesting numbers. A wee bit of Lisp will do handy, but feel free
to re-write in your favorite language:

#+BEGIN_SRC org
  ,#+NAME: cool-numbers
  ,#+BEGIN_SRC emacs-lisp
    (mapcar (lambda (i)
              (list i          (random 10)
                    (expt i 2) (random 100)
                    (expt i 3) (random 1000)))
            (number-sequence 1 10))
  ,#+END_SRC

  ,#+RESULTS: cool-numbers
  |  1 | 1 |   1 | 14 |    1 |  74 |
  |  2 | 7 |   4 | 25 |    8 | 823 |
  |  3 | 2 |   9 | 68 |   27 | 402 |
  |  4 | 4 |  16 | 17 |   64 | 229 |
  |  5 | 6 |  25 |  4 |  125 | 208 |
  |  6 | 7 |  36 | 67 |  216 | 203 |
  |  7 | 0 |  49 | 96 |  343 | 445 |
  |  8 | 0 |  64 | 58 |  512 | 908 |
  |  9 | 2 |  81 | 15 |  729 | 465 |
  | 10 | 0 | 100 | 61 | 1000 | 798 |
#+END_SRC

Instead of copying the source code and running it, you could just store the table of numbers directly in your
document, as in:

#+BEGIN_SRC org
  ,#+NAME: cool-numbers
  |  1 | 1 |   1 | 14 |    1 |  74 |
  |  2 | 7 |   4 | 25 |    8 | 823 |
  |  3 | 2 |   9 | 68 |   27 | 402 |
  |  4 | 4 |  16 | 17 |   64 | 229 |
  |  5 | 6 |  25 |  4 |  125 | 208 |
  |  6 | 7 |  36 | 67 |  216 | 203 |
  |  7 | 0 |  49 | 96 |  343 | 445 |
  |  8 | 0 |  64 | 58 |  512 | 908 |
  |  9 | 2 |  81 | 15 |  729 | 465 |
  | 10 | 0 | 100 | 61 | 1000 | 798 |
#+END_SRC

How we use and process those numbers below doesn’t change with either approach. By the way, I often create
data tables to use as parameters for testing some of my functions, let me show you how this works.

The cool-numbers table becomes an array or arrays for our block, so let’s use a Python comprehension to spit
out the values into one long array. And just to make it interesting, let’s increment each number:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python :var nums=cool-numbers :results list
    return [ cell + 1 for row in nums for cell in row ]
  ,#+END_SRC

  ,#+RESULTS:
  - 2
  - 4
  - 2
  - 23
  - 2
  - 955
  - 3
  - 7
  - 5
  - 43
  - 9
  ...
#+END_SRC

** Slicing and Dicing Tables

We can get just a single row from a table, but giving an indexed number to the cool-numbers table reference.
Check out this short Ruby block:

#+BEGIN_SRC org
  ,#+BEGIN_SRC ruby :var fifth=cool-numbers[4]
    fifth
  ,#+END_SRC

  ,#+RESULTS:
  | 5 | 9 | 25 | 93 | 125 | 524 |
#+END_SRC

We can also get just a single column in a similar way. In this case, the comma specifies that we want any row,
but the 4 limits it to just the fifth column that contains our numbers raised to the third power:

#+BEGIN_SRC org
  ,#+NAME: cubes
  ,#+BEGIN_SRC elisp :var cubes=cool-numbers[,4]
    cubes
  ,#+END_SRC

  ,#+RESULTS: cubes
  | 1 | 8 | 27 | 64 | 125 | 216 | 343 | 512 | 729 | 1000 |
#+END_SRC

** Reprocessing

The cool-numbers was used in the cubes block (that we named), and we can use the results from that block in
another block:

#+BEGIN_SRC org
  ,#+NAME: roots_of_list
  ,#+BEGIN_SRC python :var lst=cubes :results list
    import math
    return [ math.sqrt(n) for n in lst ]
  ,#+END_SRC

  ,#+RESULTS: roots_of_list
  - 1.0
  - 2.8284271247461903
  - 5.196152422706632
  - 8.0
  - 11.180339887498949
  - 14.696938456699069
  - 18.520259177452136
  - 22.627416997969522
  - 27.0
  - 31.622776601683793
#+END_SRC

* Keeping your Blocks Clean

While a block of code does something, a block of code also communicates something. Code that is necessary to
execute, but doesn’t not important to communicate with your teammates can be placed outside of the block. Here
are few examples of how that can be done.

** Environment Setup

I often query OpenStack instances with its nova command. This command reads connection credentials from
environment variables, and we often set these in resource files. A typical session would go like:

#+BEGIN_EXAMPLE
  $ source openrc
  $ nova list
#+END_EXAMPLE

The code in a block I want to communicate is the nova list, however, the source command is necessary if I want
to execute it and include the results, but not something I want exported. Put unsightly code in [[http://orgmode.org/org.html#prologue][:prologue]]
sections:

#+BEGIN_SRC org
  ,#+HEADER: :prologue "source openrc"
  ,#+BEGIN_SRC sh
    nova list
  ,#+END_SRC
#+END_SRC

Code in the :prologue will not be exported, and my team mates who receive my illustrious prose, will only see
the nova list and possibly the results of executing it.

** Using RVM

Languages like Python and Ruby often want a virtual machine to specify how something should be processed. You
can use :prologue with two backslashes to pre-pend it (for shell calls anyway):

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh :prologue "~/.rvm/bin/rvm 1.9.3@msw exec \\"
    gem list
  ,#+END_SRC
#+END_SRC

Note: Execution of Ruby or Python code is based on the [[http://www.emacswiki.org/emacs/RvmEl][rvm]], or [[http://github.com/jorgenschaefer/pyvenv][pyvenv]] or [[https://github.com/jorgenschaefer/elpy/wiki][ELPY]].

** Cleaning Results

Sometimes the results from an evaluation aren’t exactly what we want exported to our document. While we could
probably change the code, perhaps our point is the code as written.

For example, the shell command, ls -l, pre-pends an initial Total line:

The =ls= command now takes a =time-style= parameter, as in:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh
    ls -lhG --time-style long-iso
  ,#+END_SRC

  ,#+RESULTS:
  | total      | 5.8M |        |      |            |       |                                     |
  | -rw-rw-r-- |    1 | howard | 6.0K | 2015-09-02 | 17:36 | emacs-init.org                      |
  | -rw-rw-r-- |    1 | howard | 22K  | 2015-07-05 | 11:13 | eshell-fun.org                      |
  | -rw-rw-r-- |    1 | howard | 3.0K | 2015-07-05 | 11:13 | eshell.org                          |
  | -rw-rw-r-- |    1 | howard | 4.3K | 2015-09-02 | 12:52 | getting-started2.org                |
  | -rw-rw-r-- |    1 | howard | 5.1K | 2015-03-30 | 18:08 | getting-started.org                 |
  ...
#+END_SRC

This screws up our table. We could change our block to use the tail command, as in:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh
    ls -lhG --time-style long-iso | tail -n +2
  ,#+END_SRC
#+END_SRC

However, in this example, I was talking about the ls command, not the tail command. It doesn’t belong.

We can change the output from a code block using the [[http://orgmode.org/org.html#post][:post]] parameter, this allows us to have the code block we
wish to show, as well as the resulting output.

In this example, to remove the first line, we create a processor code block to return all lines except the
first. We specify none to the :exports parameter since I don’t want to have it included in any documents I may
export. Notice, the variable, data:

#+BEGIN_SRC org
  ,#+NAME: skip_first
  ,#+BEGIN_SRC elisp :var data="" :exports none
    (cdr data)
  ,#+END_SRC
#+END_SRC

Now our code block can contain just the ls -l, but we sent the output to the skip_first block. We assign its
data variable to *this* (which refers to our output), and now we only have files:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sh :post skip_first(data=*this*)
    ls -lhG --time-style long-iso
  ,#+END_SRC

  ,#+RESULTS:
  | -rw-rw-r-- |    1 | howard | 6.0K | 2015-09-02 | 17:36 | emacs-init.org                      |
  | -rw-rw-r-- |    1 | howard | 22K  | 2015-07-05 | 11:13 | eshell-fun.org                      |
  | -rw-rw-r-- |    1 | howard | 3.0K | 2015-07-05 | 11:13 | eshell.org                          |
  | -rw-rw-r-- |    1 | howard | 4.3K | 2015-09-02 | 12:52 | getting-started2.org                |
  | -rw-rw-r-- |    1 | howard | 5.1K | 2015-03-30 | 18:08 | getting-started.org                 |
  ...
#+END_SRC

The :post parameter comes in really helpful when we talk about the Tower of Babel below, as you can create a
collection of these sorts of output processors and use them in other documents.

* Miscellaneous Features

The following are some parameters and other features that didn’t seem to fit before.

** Calling Blocks

So far, our code blocks have pulled values into their code blocks with the :var parameter, however, we can
also push values into blocks by calling it elsewhere in our document.

Remember our roots_of_list block we [[http://howardism.org/Technical/Emacs/literate-programming-tutorial.html#orgheadline42][created above]]? It took a variable, lst, but here we re-call it with a
different value for its variable:

#+BEGIN_SRC org
  ,#+CALL: roots_of_list( lst='(16 144 81 61) )

  ,#+Results:
  | 4.0 | 12.0 | 9.0 | 7.810249675906654 |
#+END_SRC

We can also call it with values from the output of another code block. Here we pass in a column from our
cool-numbers table:

#+BEGIN_SRC org
  ,#+CALL: roots_of_list( lst=cool-numbers[,2] )

  ,#+RESULTS:
  | 1.0 | 2.0 | 3.0 | 4.0 | 5.0 | 6.0 | 7.0 | 8.0 | 9.0 | 10.0 |
#+END_SRC

Note: You can set additional parameters for the block inside brackets. See [[http://orgmode.org/org.html#Evaluating-code-blocks][Evaluating code blocks]] for details.

How does this look when exported? Depends on the results. If the block returned a single value, for instance,
something like:

#+BEGIN_SRC org
  ,#+NAME: cube
  ,#+BEGIN_SRC elisp :var n=0 :exports none
    (* n n n)
  ,#+END_SRC
#+END_SRC

Calling it with a table does what you expect:

#+BEGIN_SRC org
  ,#+CALL: cube[:results table](n=3)
#+END_SRC

But calling it with a list, seems to export it inside a <pre> block. YMMV, I suppose.

** Embedded Results

If you want a quickly evaluated result from a language, you can embed code in curlies. For instance, add the
following to your org file, and type C-c C-c at the beginning of the line:

#+BEGIN_SRC org
  src_ruby{ 5+6 } =11=
#+END_SRC

The answer, 11, was appended to the line. When exported, only the results are shown (not the source).

I suppose these would be most useful within the prose, as in:

#+BEGIN_SRC org
  We will be bringing src_ruby{ 5+6 } children.
#+END_SRC

Note: The answer will be wrapped in HTML <code> tags.

You can insert the results of a shell script:

#+BEGIN_SRC org
  Why do I have src_sh{ ls /tmp | wc -l } files?
#+END_SRC

Or even the insert the results from an Emacs Lisp function:

#+BEGIN_SRC org
  src_elisp{ org-agenda-files }
#+END_SRC

Also supports calling blocks too. For instance, we defined a block of code earlier and named it roots_of_list,
and this can be called:

#+BEGIN_SRC org
  call_roots_of_list( lst=cool-numbers[,2] )
  | 1.0 | 2.0 | 3.0 | 4.0 | 5.0 | 6.0 | 7.0 | 8.0 | 9.0 | 10.0 |
#+END_SRC

Warning: During my workshop, when I was demonstrating this feature, we noticed that if you C-c C-c the src_XYZ
feature to embed the answer, when you export it, you will have two answers. The one you embedded and the
results of evaluating the code during the exporting.

** Library of Babel

The Library of Babel is a collection of code blocks accessible to any org-mode file. Like the Gem resources
for Ruby, you specify the files containing named blocks that should be accessible.

Do this by following these steps:

  * Create a new org-mode file with at least one named block
  * Once in your Emacs session: C-c C-v i
  * Select your new file to specify that this should be added to babel collection.

Try it out with a code block that might be nice to use:

#+BEGIN_SRC org
  ,#+NAME: take
  ,#+BEGIN_SRC elisp :var data='() only=5
    (require 'cl)
    (flet ((take (remaining lst)
                 (if (> remaining 0)
                   (cons (car lst) (take (1- remaining) (cdr lst)))
                   '("..."))))
      (take only data))
  ,#+END_SRC
#+END_SRC

After you have saved this new file, and loaded it as a babel addition, let’s use it with a :post parameter:

#+BEGIN_SRC org
  ,#+BEGIN_SRC python :post take(data=*this*, only=3)
    return [x * x for x in range(1, 20)]
  ,#+END_SRC

  ,#+RESULTS:
  | 1 | 4 | 9 | ... |
#+END_SRC

This feature is really helpful with:

  * :post processing output
  * #+CALL where you want just the results on line
  * call_XYZ() where you want results embedded inline

For a more permanent addition to your tower, add a call to org-babel-lob-ingest with each file to your Emacs
init file.

* Specialized Languages

I’ve found a few programming languages that really add to an org-mode way of writing documents.

** SQL

The ability to query a database with SQL statements, and then manipulate the results in other languages is
quite interesting, and if I felt I could have used them, would have made this workshop-tutorial less trivial
(but also less accessible).

Assuming that you have installed [[https://www.sqlite.org][Sqlite]], and loaded the library in Emacs with: M-x load-library then ob-sqlite

You can then specify a :db parameter to a database created by calling .backup in the Sqlite command line
program. We can then write blocks like:

#+BEGIN_SRC org
  ,#+BEGIN_SRC sqlite :db dolphins.db
    SELECT gender,COUNT(gender) FROM oasis GROUP BY gender;
  ,#+END_SRC

  ,#+RESULTS:
  | f | 55 |
  | m | 89 |
#+END_SRC

Which renders a nice, simple table:

f 55 
m 89 

If you like this idea, check out my [[http://howardism.org/Technical/Emacs/literate-database.html][Literate Database essay]].

** Graphviz

If you have [[http://www.graphviz.org/][Graphviz]] installed, we can create an diagram directly from your document:

#+BEGIN_SRC org
  ,#+BEGIN_SRC dot :file some-illustration.png
    digraph {
      a -> b;
      b -> c:
      c -> a;
    }
  ,#+END_SRC
#+END_SRC

[[http://howardism.org/Technical/Emacs/literate-programming-graphviz.png]]

For these, I often set :exports results so that the code to generate the image isn’t exported.

Warning: If you wish to execute the code block to generate an image, the language needs to be set to dot, but
if you want to edit the code in a side buffer (with the C-c ’ … apostrophe), you need to change the language
to graphviz-dot.

** PlantUML

If you have [[http://plantuml.sourceforge.net/download.html][PlantUML]] installed, you can do something like:

#+BEGIN_SRC org
  ,#+BEGIN_SRC plantuml :file sequence.png :exports results
    @startuml sequence-diagram.png

      Alice -> Bob: synchronous call
      Alice ->> Bob: asynchronous call

    @enduml
  ,#+END_SRC
#+END_SRC

[[http://howardism.org/Technical/Emacs/literate-programming-plantuml.png]]

Hrm… have descriptive illustrations associated with your source code?

** Calc

We have access the impressive [[http://howardism.org/Technical/Emacs/calc.html#Top][Emacs Calculator]] as well to use a more normal mathematical syntax.

#+BEGIN_SRC org
  ,#+BEGIN_SRC calc :var a=2 b=9 c=64 x=5
    ((a+b)^3 + sqrt(c)) / (2x+1)
  ,#+END_SRC

  ,#+RESULTS:
  : 121.727272727
#+END_SRC

Let’s simplify a formula by leaving out some of the values for a variable:

#+BEGIN_SRC org
  ,#+BEGIN_SRC calc :var a=4 b=2
    ((a+b)^3 + sqrt(c)) / (2x+1)
  ,#+END_SRC

  ,#+RESULTS:
  : (sqrt(c) + 216) / (2 x + 1)
#+END_SRC

You may need to load it: M-x load-library and type: ob-calc

Keep in mind that each line of each calc block is placed on the stack in the Calc mode buffer (see it with C-x * *).

* Summary

Here is a summary listing of the [[http://orgmode.org/org.html#Specific%2520header%2520arguments][header arguments]], separated based on your goal or needs:

  * Code Evaluation?
   
    [[http://orgmode.org/org.html#dir][dir]]
        specify directory the code should run … Tramp?
    [[http://orgmode.org/org.html#session][session]]
        re-use interpreter between code blocks
    [[http://orgmode.org/org.html#file][file]]
        write results to the file system
    [[http://orgmode.org/org.html#eval][eval]]
        limit evaluation of specific code blocks
    [[http://orgmode.org/org.html#cache][cache]]
        cache eval results to avoid re-evaluation of blocks
    [[http://orgmode.org/org.html#var][var]]
        setting variables for a block (ignore with no-expand)
   
  * Exporting?
   
    [[http://orgmode.org/org.html#results][results]]
        either output or value and the formatting
    [[http://orgmode.org/org.html#exports][exports]]
        how the code and results should be exported
   
  * Literate Programming?
   
    [[http://orgmode.org/org.html#tangle][tangle]]
        how the source written to a script file … this is literate programming.
    [[http://orgmode.org/org.html#mkdirp][mkdirp]]
        create parent directory of tangled source file
    [[http://orgmode.org/org.html#shebang][shebang]]
        the initial line written to tangled files
    [[http://orgmode.org/org.html#noweb][noweb]]
        toggle expansion of noweb references
    [[http://orgmode.org/org.html#noweb-ref][noweb-ref]]
        resolution target for noweb references
   
  * Special Input?
   
    [[http://orgmode.org/org.html#prologue][prologue]]
        text to prepend to code block body
    [[http://orgmode.org/org.html#epilogue][epilogue]]
        text to append to code block body
   
  * Special Output and Formatting?
   
    [[http://orgmode.org/org.html#padline][padline]]
    [[http://orgmode.org/org.html#post][post]]
        post processing of code block results
    [[http://orgmode.org/org.html#wrap][wrap]]
    Misc.
        [[http://orgmode.org/org.html#hlines][hlines]], [[http://orgmode.org/org.html#colnames][colnames]], [[http://orgmode.org/org.html#rownames][rownames]]
   
Footnotes:

^[[http://howardism.org/Technical/Emacs/literate-programming-tutorial.html#fnr.1][1]]

The term noweb is from Knuth’s original program for tangling out source code. Since each code block could be 
re-inserted into other blocks, he saw this as creating a tangled web of connections.
