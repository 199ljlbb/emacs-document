#+URL: http://nullprogram.com/blog/2014/01/04/

并没有文档说明Emacs是如何将源代码编译成字节码的 — 特别是是Emacs最近进行了一次升级,开始支持静态作用于了- 这部分资料尤其少. 
大多数用于对于Elisp编译的理解仅限于编译的结果是保存在 =.elc= 文件中,以及字节码加载起来要比未编译的Elisp要快.
对于用户来说,知道这两点基本上也足够了, GNU Emacs Lisp Reference Manual 也明确不鼓励深入了解该编译过程.

#+BEGIN_QUOTE
    人不会去手写字节码; 字节码由编译器产出就行了. 不过为了满足你的好奇心,我们也是有提供一个反汇编工具给你用.
#+END_QUOTE
   
什么鬼! 你怎么知道我不想手写字节码? :-) 本文就将带领你了解一下Elisp编译器的内部. 我会解释一下它的工作原理,静态作用域速度更快的秘密并展示一下如何手写字节码.

* The Humble Stack Machine

Emacs的字节码解释器就是一个简单的堆栈机. 它用栈来存放lisp对象. 解释器是向后兼容的,但是无法向前兼容(即旧版本的解释器无法运行新版本的字节码).
每条指令占用1到3个字节大小. 第一个字节存放的是操作码,而第二,第三个字节存放的是操作数或者间接值. 不过有些操作数也会被压缩进操作码字节中.

写作该文时 (Emacs 24.3) Emacs共有142个操作码, 其中6已经被废弃了. 大多数的操作码都与那些常用的内置函数相关(看看那些内置函数,你会发现Elisp真的在优化文本处理上费了大劲了!). 
考虑到有些操作码只是将其他操作码与操作数整合在一起,有多达27个操作码是预备给以后用的.

+ opcodes 48 - 55
+ opcode 97
+ opcode 128
+ opcodes 169 - 174
+ opcodes 180 - 181
+ opcodes 183 - 191

查询操作码列表的最方便途径是查询 [[http://cvs.savannah.gnu.org/viewvc/emacs/emacs/lisp/emacs-lisp/bytecomp.el?view=markup][bytecomp.el]] 中的内容. 不过要小心,其中有些操作码的注释已经过时了.

* Segmentation Fault Warning

字节码可比普通Elisp代码要危险得多. *它甚至可能导致Emacs崩溃*. 你可以试试运行一下(译者注:这里的\300和\207都是特殊字符,而不是普通的字符串),

#+BEGIN_SRC shell
  emacs -batch -Q --eval '(print (#[0 "\300\207" [] 0]))'
#+END_SRC

或者手工执行下面这段代码(请先保存好其他资料!),

#+BEGIN_SRC emacs-lisp
  (#[0 "\300\207" [] 0])
#+END_SRC

之所以产生这个segfault,并不是因为Emacs有BUG,而是是因为这段代码尝试跨界引用了常量数组后面的元素(caused by referencing beyond the end of the constants vector). 
因为进行边界检查会拖慢解释器的速度,因此基于实用性的考虑,在运行期并不会进行边界检查.
Emacs开发人员默认所执行的字节码肯定是由编译器产生的有效代码, 对于手写代码不保证没有问题.

#+BEGIN_QUOTE
    永远不要尝试自己去编写字节码函数,它可能会与你的Emacs不相容从而在调用该函数时引起Emacs崩溃. 
    让编译器帮你做做这件事情;它产出的字节码肯定是相容的(希望是吧).
#+END_QUOTE
   
我已经提前给你打好预防针了. 现在开始玩火吧.

* The Byte-code Object

字节码对象,在功能上等价于普通的Elisp数组,只不过它同时还可以作为函数来执行.
两者的元素访问时间都是常量,语法也很接近(=[...]= vs. =#[...]=),对其中元素的数量理论上也是没有限制的(不过一个合法的函数至少都会有4个元素).

有两种方法可以用来创建字节码对象: 使用字面量表示法或调用 =make-byte-code= 函数. [[http://nullprogram.com/blog/2012/07/17/][跟数组的字面量一样]], 字节码的字面量也不需要被引用起来.

#+BEGIN_SRC emacs-lisp
  (make-byte-code 0 "" [] 0)
  ;; => #[0 "" [] 0]

  #[1 2 3 4]
  ;; => #[1 2 3 4]

  (#[0 "" [] 0])
  ;; error: Invalid byte opcode
#+END_SRC

一个字节码对象的字面量可以包括以下这些元素:

  * 函数参数列表
  * 表示字节码的单字节字符串
  * 常量数组
  * 最大栈使用量(Maximum stack usage)
  * Docstring (可选,没有的话为nil)
  * Interactive声明(可选)

** Parameter List

参数列表依据该函数是在动态作用域下还是静态作用域下而有两种形式. 如何是在动态作用域下,那么它跟lisp代码中的参数列表一模一样.

#+BEGIN_SRC emacs-lisp
  (byte-compile (lambda (a b &optional c)))
  ;; => #[(a b &optional c) "\300\207" [nil] 1]
#+END_SRC

我们不能修改参数名称,因此确实也没有更简短的表示参数列表的方法了. 请记住,因为在动态作用域下,函数体执行时,这些参数是要与外部变量绑定在一起的.

当函数是在静态作用域中时,则参数列表会被打包成一个Elisp整数,用于指明有多少参数是必须的,有多少参数是 =&optional= 的,以及是否有 =&rest= 参数.

[[http://nullprogram.com/img/diagram/elisp-params.png]]

最后7位表示的是必填参数个数. 请注意,这使得静态作用域下编译后的函数最多只能有127个必填参数. 
第8为指明是否有 =&rest= 参数(1表示有). 剩下的字节表示的是必填参数与 =&optional= 参数的数量和(不包括 =&rest= 参数). 
你把整数的16进制画出来后就很清晰了,每一部分的意义都是非常明确的.

#+BEGIN_SRC emacs-lisp
  (byte-compile-make-args-desc '())
  ;; => #x000  (0 args, 0 rest, 0 required)

  (byte-compile-make-args-desc '(a b))
  ;; => #x202  (2 args, 0 rest, 2 required)

  (byte-compile-make-args-desc '(a b &optional c))
  ;; => #x302  (3 args, 0 rest, 2 required)

  (byte-compile-make-args-desc '(a b &optional c &rest d))
  ;; => #x382  (3 args, 1 rest, 2 required)
#+END_SRC

在静态作用域下,这些参数的名称变得无关紧要了: 它们只是单纯地与出现的位置相关. 这种紧凑的参数声明式也是静态作用域能更快的原因之一: 解释器无需在每次函数调用时都解析整个lambda表达式然后为各参数分配绑定的变量.

** Unibyte String Byte-code

The second element is a unibyte string — it strictly holds octets and is not to be interpreted as any sort of Unicode encoding. These
strings should be created with unibyte-string because string may return a multibyte string. To disambiguate the string type to the lisp
reader when higher values are present (> 127), the strings are printed in an escaped octal notation, keeping the string literal inside the
ASCII character set.

#+BEGIN_SRC emacs-lisp
  (unibyte-string 100 200 250)
  ;; => "d\310\372"
#+END_SRC

It’s unusual to see a byte-code string that doesn’t end with 135 (#o207, byte-return). Perhaps this should have been implicit? I’ll talk
more about the byte-code below.

** Constants Vector

The byte-code has very limited operands. Most operands are only a few bits, some fill an entire byte, and occasionally two bytes. The meat
of the function that holds all the constants, function symbols, and variables symbols is the constants vector. It’s a normal Elisp vector
and can be created with vector or a vector literal. Operands reference either this vector or they index into the stack itself.

#+BEGIN_SRC emacs-lisp
  (byte-compile (lambda (a b) (my-func b a)))
  ;; => #[(a b) "\302\134\011\042\207" [b a my-func] 3]
#+END_SRC

Note that the constants vector lists the variable symbols as well as the external function symbol. If this was a lexically scoped function
the constants vector wouldn’t have the variables listed, being only [my-func].

** Maximum Stack Usage

This is the maximum stack space used by this byte-code. This value can be derived from the byte-code itself, but it’s pre-computed so that
the byte-code interpreter can quickly check for stack overflow. Under-reporting this value is probably another way to crash Emacs.

** Docstring

The simplest component and completely optional. It’s either the docstring itself, or if the docstring is especially large it’s a cons cell
indicating a compiled .elc and a position for lazy access. Only one position, the start, is needed because the lisp reader is used to load
it and it knows how to recognize the end.

** Interactive Specification

If this element is present and non-nil then the function is an interactive function. It holds the exactly contents of interactive in the
uncompiled function definition.

#+BEGIN_SRC emacs-lisp
  (byte-compile (lambda (n) (interactive "nNumber: ") n))
  ;; => #[(n) "\010\207" [n] 1 nil "nNumber: "]

  (byte-compile (lambda (n) (interactive (list (read))) n))
  ;; => #[(n) "\010\207" [n] 1 nil (list (read))]
#+END_SRC

The interactive expression is always interpreted, never byte-compiled. This is usually fine because, by definition, this code is going to
be waiting on user input. However, it slows down keyboard macro playback.

* Opcodes

The bulk of the established opcode bytes is for variable, stack, and constant access opcodes, most of which use packed operands.

  * 0 - 7 : (stack-ref) stack reference
  * 8 - 15 : (varref) variable reference (from constants vector)
  * 16 - 23 : (varset) variable set (from constants vector)
  * 24 - 31 : (varbind) variable binding (from constants vector)
  * 32 - 39 : (call) function call (immediate = number of arguments)
  * 40 - 47 : (unbind) variable unbinding (from constants vector)
  * 129, 192-255 : (constant) direct constants vector access

Except for the last item, each kind of instruction comes in sets of 8. The nth such instruction means access the nth thing. For example,
the instruction “2” copies the third stack item to the top of the stack. An instruction of “9” pushes onto the stack the value of the
variable named by the second element listed in the constants vector.

However, the 7th and 8th such instructions in each set take an operand byte or two. The 7th instruction takes a 1-byte operand and the 8th
takes a 2-byte operand. A 2-byte operand is written in little-endian byte-order regardless of the host platform.

For example, let’s manually craft an instruction that returns the value of the global variable foo. Each opcode has a named constant of
byte-X so we don’t have to worry about their actual byte-code number.

#+BEGIN_SRC emacs-lisp
  (require 'bytecomp)  ; named opcodes

  (defvar foo "hello")

  (defalias 'get-foo
    (make-byte-code
     #x000                 ; no arguments
     (unibyte-string
      (+ 0 byte-varref)   ; ref variable under first constant
      byte-return)        ; pop and return
     [foo]                 ; constants
     1))                   ; only using 1 stack space

  (get-foo)
  ;; => "hello"
#+END_SRC

Ta-da! That’s a handcrafted byte-code function. I left a “+ 0” in there so that I can change the offset. This function has the exact same
behavior, it’s just less optimal,

#+BEGIN_SRC emacs-lisp
  (defalias 'get-foo
    (make-byte-code
     #x000
     (unibyte-string
      (+ 3 byte-varref)     ; 4th form of varref
      byte-return)
     [nil nil nil foo]
     1))
#+END_SRC

If foo was the 10th constant, we would need to use the 1-byte operand version. Again, the same behavior, just less optimal.

#+BEGIN_SRC emacs-lisp
  (defalias 'get-foo
    (make-byte-code
     #x000
     (unibyte-string
      (+ 6 byte-varref)     ; 7th form of varref
      9                     ; operand, (constant index 9)
      byte-return)
     [nil nil nil nil nil nil nil nil nil foo]
     1))
#+END_SRC

Dynamically-scoped code makes heavy use of varref but lexically-scoped code rarely uses it (global variables only), instead relying
heavily on stack-ref, which is faster. This is where the different calling conventions come into play.

* Calling Convention

Each kind of scope gets its own calling convention. Here we finally get to glimpse some of the really great work by Stefan Monnier
updating the compiler for lexical scope.

** Dynamic Scope Calling Convention

Remembering back to the parameter list element of the byte-code object, dynamically scoped functions keep track of all its argument names.
Before executing a function the interpreter examines the lambda list and binds (varbind) every variable globally to an argument.

If the caller was byte-compiled, each argument started on the stack, was popped and bound to a variable, and, to be accessed by the
function, will be pushed back right onto the stack (varref). There’s a lot of argument indirection for each function call.

** Lexical Scope Calling Convention

With lexical scope, the argument names are not actually bound for the evaluation byte-code. The names are completely gone because the
compiler has converted local variables into stack offsets.

When calling a lexically-scoped function, the byte-code interpreter examines the integer parameter descriptor. It checks to make sure the
appropriate number of arguments have been provided, and for each unprovided &optional argument it pushes a nil onto the stack. If the
function has a &rest parameter, any extra arguments are popped off into a list and that list is pushed onto the stack.

From here the function can access its arguments directly on the stack without any named variable misdirection. It can even consume them
directly.

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
  (defun foo (x) x)

  (symbol-function #'foo)
  ;; => #[#x101 "\207" [] 2]
#+END_SRC

The byte-code for foo is a single instruction: return. The function’s argument is already on the stack so it doesn’t have to do anything.
Strangely the maximum stack usage element is wrong here (2), but it won’t cause a crash.

#+BEGIN_SRC emacs-lisp
  ;; (As of this writing `byte-compile' always uses dynamic scope.)

  (byte-compile 'foo)
  ;; => #[(x) "\010\207" [x] 1]
#+END_SRC

It takes longer to set up (x is implicitly bound), it has to make an explicit variable dereference (varref), then it has to clean up by
unbinding x (implicit unbind). It’s no wonder lexical scope is faster!

Note that there’s also a disassemble function for examining byte-code, but it only reveals part of the story.

#+BEGIN_SRC emacs-lisp
  (disassemble #'foo)
  ;; byte code:
  ;;   args: (x)
  ;; 0       varref    x
  ;; 1       return
#+END_SRC

* Compiler Intermediate “lapcode”

The Elisp byte-compiler has an intermediate language called lapcode (“Lisp Assembly Program”), which is much easier to optimize than
byte-code. It’s basically an assembly language built out of s-expressions. Opcodes are referenced by name and operands, including packed
operands, are handled whole. Each instruction is a cons cell, (opcode . operand), and a program is a list of these.

Let’s rewrite our last get-foo using lapcode.

#+BEGIN_SRC emacs-lisp
  (defalias 'get-foo
    (make-byte-code
     #x000
     (byte-compile-lapcode
      '((byte-varref . 9)
        (byte-return)))
     [nil nil nil nil nil nil nil nil nil foo]
     1))
#+END_SRC

We didn’t have to worry about which form of varref we were using or even how to encode a 2-byte operand. The lapcode “assembler” took care
of that detail.

* Project Ideas?

The Emacs byte-code compiler and interpreter are fascinating. Having spent time studying them I’m really tempted to build a project on top
of it all. Perhaps implementing a programming language that targets the byte-code interpreter, improving compiler optimization, or, for a
really big project, JIT compiling Emacs byte-code.

*People can write byte-code!*
