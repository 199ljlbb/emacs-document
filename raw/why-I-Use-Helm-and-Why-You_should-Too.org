#+TITLE: why-I-Use-Helm-and-Why-You_should-Too
#+URL: http://thescratchcastle.com/posts/emacs-and-helm.html                                                
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-02 二 09:38]
#+OPTIONS: ^:{}

对于初学者来说,Emacs就是个满是快捷键和命令的怪物. 由于Emacs不像VIM那样是一个真正的true modal,因此你需要学习大量的快捷键才能有效地编辑文本.
GNU Emacs的创造者,Richard Stallman,对此深有感触,于是为Emacs的资深用户创造出了一款专用键盘:"GNU Emacs Human Interface Machine".

下面这张照片就是其中一款"GNU Emacs Human Interface Machine"
[[http://thescratchcastle.com/img/emacs-human-interface-machine.jpg]]

不开玩笑了, 若你不了解要执行的命令名称和快捷键的话,Emacs的默认界面确实是不够友好. 你可能执行了一个命令,这个命令在等待你的输入,但是你所能看到仅仅是一个空白的提示框而已.
如果你阅读过一些资料的话,可能会知道你按下TAB键就会列出可选项供你选择了. 我想这总比要全部手工输入要好点,但是如果能做到在等待你输入时直接就让你看到你的可选项的话,那就更好了.
用Helm就能做到这一点.

[[https://github.com/emacs-helm/helm][Helm]] 是一个Emacs的扩展插件, 它会給很多要求用户输入的命令都加上hooks,并用一个新命令替代了这些旧命令. 
新命令不仅仅展示給用户一个提示窗口,而且还有一个由可选项组成的交互式的列表,而且列表中的选项会与你的输入进行模糊匹配并过滤掉那些不匹配的选项.
它有点类似于Sublime Text总的 [[http://docs.sublimetext.info/en/latest/file_management/file_management.html][goto anything]] 命令.

假设我想要找出一个命令可以将window分割成垂直的两部分,但是我只能记得这个命令名字中包含有'window'和'split',却不记得名字是以什么开头的. 通过 =helm-apropos= 命令可以很容易的浏览当前Emacs环境中的那些可用的symbols.

[[http://thescratchcastle.com/img/helm-apropos.gif]]

在上面的demo中,我运行了 =helm-apropos= 并且尝试搜索那些名字中'window'在前,'split'在后的那些命令. 结果没找到符合条件的选项. 所以我重新开始并搜索名字中'split'在前,'window'在后的名字. 最终我找到了那个命令: =split-window-right=.

There's an important feature to note about this kind of UI that isn't immediately obvious. 
由于所有的可能性都展示在了你面前,最终你可以通过使用程序来了解到这个程序的功能. 其结果是安装了helm后,Emacs变得要容易理解的多.
helm对Emacs体验的改进如此之大,以至于如果Emacs不再能用helm的话,我可能会考虑换成其他的编辑器.

下面我列出了一些常用的helm命令以及我喜爱的基于helm扩展的package.

* Built-In Helm Commands

** helm-find-file / Bound to C-x C-f

使用该命令可以在你的文件系统中导航并打开文件. =helm-find-file= 会列出你当前工作目录下的所有文件. 
按下 =C-l= 会让你跳到父级目录.
若你的光标处于目录上,按下 =C-j= 会进入该目录.
按下回车会打开文件.
很简单对不对.

[[http://thescratchcastle.com/img/helm-find-file.gif]]

** helm-M-x / Bound to C-m

该命令与 =helm-apropos= 很类似,不同点在于它只会显示命令列表,并且按下回车会直接执行该命令.

[[http://thescratchcastle.com/img/helm-M-x.gif]]

推荐使用 =helm-M-x= 作为 =M-x= 的替代.

** helm-google / No default binding

使用helm搜索Google. 该命令的一个有点在于结果会随着你的输入而改变,就好像你在浏览器中搜索google一样. 按下回车会用你的默认浏览器打开相应的链接.

[[http://thescratchcastle.com/img/helm-google.gif]]

** helm-apropos / Bound to C-x c a

=helm-apropos= 会显示所有可能的命令,函数,变量和face的symbol. 你可以理解为它能显示出所有Emacs中定义过的东西. 按下回车后就能看到相关的帮助信息了.
使用该命令要注意的一件事情是:symbol列表是会随着Emacs的运行不断改变的. 这是因为Emacs就好像,怎么说呢,泥土一样. 你可能没有注意到这一点,但是Emacs是一个动态的lisp环境. 你可以随时更改某个已定义symbol的意义,也可以新增新的symbol而无需重启Emacs.
你可能看过在[[https://www.youtube.com/watch?v=7XUWpze_A_s][live lisp environment]] 中编程的一些展示,这就是隐藏在那些展示后面的黑魔法.

* Helm Extensions

** helm-dash

The helm-dash package lets you search programming language documentation through "docsets" you've installed on
your machine. Install docsets for a language using the 'helm-dash-install-docset' command and search them
using the 'helm-dash' command. Press RETURN on a result to open the documentation in your default browser.

[[https://github.com/areina/helm-dash][helm-dash github]]

** evalator

Evalator is a new kind of REPL that I wrote for Emacs that lets you interactively transform data. It evaluates
expressions in Emacs Lisp by default but it can support any language provided you've installed the evaluation
context package.

I use evalator mainly as a calculator and a quick experimentation tool when I'm writing Emacs Lisp and Clojure
code. It feels much quicker than using a normal REPL because expressions are evaluated automatically.

Evalator starts with a prompt where you supply an expression to generate the initial data. Following
expressions transform that data on a per-element basis so its very easy to transform lists and other
collections. You can also use evalator in explicit mode, which allows you to transform data as usual, but it
lets you generate the equivalent code of the entire transformation.

[[https://github.com/seanirby/evalator][evalator github]]

** helm-descbinds

I really love this one. helm-descbinds shows you all the shortcuts that can be executed based on your current
major-mode and minor modes.[[https://github.com/emacs-helm/helm-descbinds][helm-descbinds github]]

** helm-projectile

If you've ever wanted to browse all the files in a particular directory ala Sublime Text then you want
helm-projectile.helm-projectile is a helm extension for the projectile package, which provides utilities for
managing your programming projects. A project is essentially a folder with files. Projects are automatically
added to projectile if they have a VCS directory like a '.git' or '.svn'.There are tons of useful projectile
commands I could demo, but [[http://tuhdo.github.io/helm-projectile.html][tuhdo covered this better than I ever could]].

[[http://tuhdo.github.io/helm-projectile.html][helm-projectile github]]

I hope by now that I've convinced you to check out helm. It really is an innovative way of interacting with
Emacs.

* UPDATE (2/18/2016):

After sharing this article on the [[https://reddit.com/r/emacs][Emacs subreddit]], I received an excellent comment from an Emacs package
author I admire very much, [[https://github.com/abo-abo][Oleh Krehel]], AKA abo-abo. He makes [[https://github.com/abo-abo/hydra][some]] [[https://github.com/abo-abo/lispy][very]] [[https://github.com/abo-abo/avy][innovative]] [[https://github.com/abo-abo/swiper][tools]] for Emacs including a
completion framework called [[http://oremacs.com/2015/04/16/ivy-mode/][ivy]], which many Emacs users prefer to helm.

In his reply, Oleh argues that if the built-in Emacs function completing-read were updated, then packages that
extend helm could be used in all the different completion frameworks. This includes ivy, icicles, ido, and
others. [[https://www.reddit.com/r/emacs/comments/46ibsx/why_i_use_helm_and_why_you_should_too/d05pdow][Here's the conversation]] and I've included his comment below(formatting has been added):

    Nice article, very good-looking presentation.
   
    However, you repeat the opinion that the completion (which is a great thing to have) is welded to the
    method of presenting said completion (in this case, Helm). Many other people do this as well, with 112
    packages in MELPA having "helm-" in their name. Hard-wiring completion to helm prevents access to ~100
    packages for users that like other methods of presenting completion.
   
    In the short run, it's convenient to live in Helm's bubble: assume that Helm is all you'll ever need and
    hard-wire everything to Helm. But most helm-foo packages out there simply consist of three things:
   
     1. Functions that generate the list of strings.
     2. Functions that take a single string - the selected candidate, and do something with it.
     3. The helm glue that wires the first group to the second.
   
    The non-helm people could make use of the functions in group-1 and group-2. The two problems they face:
    There's no glue. This could be solved by completing packages relying on the built-in completing-read more.
    There's a helm dependency. This isn't severe, but if you don't use helm you don't want to pay the overhead
    of (require 'helm) and having to update helm from the package manager.
   
    These two problems can be solved eventually by having a better completing-read API in the core. So that a
    package that only wants to provide completion can call completing-read and not be tied to any completion
    presentation framework. Two new parameters would be especially good to have: action - a lambda that
    decides what to do with the selected candidate, and caller - a symbol that identifies the completion
    session for purposes of customization (since this-command isn't reliable).
   
    Example translation
   
    Before:
   
    Here we have helm-rhythmbox, an excellent package that provides a function from group-1 -
    helm-rhythmbox-candidates that produces a list of songs on your system; and two functions from group-2 -
    helm-rhythmbox-play-song and helm-rhythmbox-enqueue-song that act on the selected song.
   
    #+BEGIN_SRC emacs-lisp
      (defvar helm-source-rhythmbox-track-search
        '((name . "Rhythmbox")
          (candidates . helm-rhythmbox-candidates)
          (action . (("Play song" . helm-rhythmbox-play-song)
                     ("Enqueue song" . helm-rhythmbox-enqueue-song)))
          (init . (lambda () (unless rhythmbox-library
                               (rhythmbox-load-library))))))
          ;;;###autoload
      (defun helm-rhythmbox ()
        "Choose a song from the Rhythmbox library to play or enqueue."
        (interactive)
        (helm :sources '(helm-source-rhythmbox-track-search)
              :buffer "*helm-rhythmbox*"))
    #+END_SRC
    
    After:
   
    #+BEGIN_SRC emacs-lisp
      ;;;###autoload
      (defun rhythmbox ()
        "Choose a song from the Rhythmbox library to play or enqueue."
        (interactive)
        (unless rhythmbox-library
          (rhythmbox-load-library))
        (completing-read "Rhythmbox: " (helm-rhythmbox-candidates)
                         nil nil nil nil nil nil
                         'helm-rhythmbox-play-song
                         'rhythmbox))
      ;; ideally, the following sections are not needed at all
      (eval-after-load 'helm
        ;; non-essential helm-specific customization via the 'rhythmbox key
        )
      (eval-after-load 'ivy
        ;; non-essential ivy-specific customization via the 'rhythmbox key
        )
    #+END_SRC
    
    Now we have a rhythmbox command that could act in exactly the same way as helm-rhythmbox when helm-mode
    (available with Helm) is on. But this command would also work excellently with Ivy or Ido or Icicles or
    Icomplete or built-in completion. This command could live in a rhythmbox package that does not depend on
    helm, since it doesn't use anything Helm-specific.
   
I'm glad Oleh joined in on the discussion and I think he makes a great case for why the completing-read
function should be updated. Thanks Oleh!
