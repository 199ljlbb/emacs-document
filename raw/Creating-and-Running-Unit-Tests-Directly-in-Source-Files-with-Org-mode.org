#+TITLE: Creating-and-Running-Unit-Tests-Directly-in-Source-Files-with-Org-mode
#+URL: http://fgiasson.com/blog/index.php/2016/05/30/creating-and-running-unit-tests-directly-in-source-files-with-org-mode/
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-09-14 三 14:53]
#+OPTIONS: ^:{}

编程可不是件容易的事情. 它需要持续的注意力. 任何对它的打断都意味着需要再花时间让注意力重新集中起来而且很容易有失误发生.
整个过程涉及到从分析问题到解决问题的一系列的过程. 我们需要分析出要解决的问题然后将解决方案写下来. 最后我们还需要写一些测试来证明我们的实现是没有问题的,并且不会被后续的修改改错了.

过去的19年里,我一直为一件事情而发愁 — 这应该是所有程序员的通病吧 — 那就是开发过程的每一步都是像瀑布一样完成上一个步骤才能开始下一个步骤.
无论是开发工具还是方法论都要求我们独立的完成这些步骤,然后进入下一个步骤.

1. 分析要解决的问题
2. 编写解决问题的代码
3. 为实现编写文档
4. 为实现编写测试案例
5. 若问题发生了改变,或者解决方案需要修正,则重复1到4步.

问题在于,在deadline的压力下,很难保持注意力和意志力来完成每个步骤. 一般来说第一步和第二步都会做,但是第三步和第四步则永远被拖延.

当然,要解决这个问题没有一定的方法. 开发程序可不是件容易的事,它需要大量的专注力. 不过我认为应该有一些方法论和工具能让整个过程变得更平滑一些.
我觉得解决该问题的最好方法就是将一个文档作为所有活动的中心.

我们希望能只在一份文档中,用一个工具就能完成所有的步骤,这样一来我们在开发的过程中就不用分心在多个工具之间切换了.

在本文中,我将会告诉你一种方法,能够让你在专注于在一份(org-mode)文档中编写解决方案与实现方法的同时完成开发,运行,测试等工作.

本文属于Clojure文学编程系列博文的一部分:

  * [[http://fgiasson.com/blog/index.php/2016/07/06/literate-clojure-programming-using-org-mode/][Project folder structure]]
  * [[http://fgiasson.com/blog/index.php/2016/08/11/literate-clojure-programming-anatomy-of-a-org-mode-file/][Anatomy of a Org-mode file]]
  * Tangling all project files
  * Publishing documentation in multiple formats
  * [[http://fgiasson.com/blog/index.php/2016/05/30/creating-and-running-unit-tests-directly-in-source-files-with-org-mode/][Unit Testing]] (this post)

* Literate Programming

关于文学式编程,每个人的理解可能都不一样. 我会在之后发布一系列关于这个的文章. 不过我现在想说的是,文学式编程的理念催生出了一批工具来帮助开发者在单个文档中完成所有的开发过程,从而防止分散他们的注意力. 而Emacs中的Org-mode就是其中一款工具.

* Unit Testing in Org-mode (for Clojure)

我在本文中会演示用Org-mode来:

1. 直接在函数后面编写一系列相关的单元测试案例
2. 在修改了被测试的函数后运行这些测试.

单元测试可以用来完成各项任务. 其最主要的目的是测试函数的行为,确定对该函数的任何修改都符合要求.
不过单元测试也可以作为展示如何使用该函数的文档来用,它能够起到诸如演示哪些参数可以传递给函数,这些函数起到什么作用,等等功能.
不管怎么说,让测试代码尽可能的靠近要测试的函数定义是很有用的. 不过在大多数的开发环境下,是及其苦难的, 好在Org-mode能帮助我们做到这一点.

现在让我们看看如何在开发过程中直接在Org-mode文件中定义单元测试.
我们的目标是在编写应用代码的同时编写单元测试代码,而且在这些代码的附近还需要有相关的说明.
我们不会分别实施开发的那四个步骤,相反我们会在同一个文档中将这四个步骤融为一体.
The goal is that all this should happen at the same time such that the focus doesn’t change all the time.

下面假设我们有一个函数计算N的阶乘.

#+BEGIN_SRC clojure
(defn n!
  [n]
  (loop [x n 
         f 1]
    (if (or (= x 1)
            (= x 0))
      f
      (recur (dec x) (* f x)))))
#+END_SRC

我们可以测试一下这个函数:

#+BEGIN_SRC clojure
(n! 10)

3628800
#+END_SRC

现在我们再来定义一些测试案例:

#+BEGIN_SRC clojure
(require '[clojure.test :refer :all])

(deftest test-n!-0
  (testing "Testing the n! function for the value 0"
    (is (= 1 (n! 0)))))

(deftest test-n!-1
  (testing "Testing the n! function for the value 1"
    (is (= 1 (n! 1)))))

(deftest test-n!-2
  (testing "Testing the n! function for the value 2"
    (is (= 2 (n! 2)))))

(deftest test-n!-4
  (testing "Testing the n! function for the value 4"
    (is (= 24 (n! 4)))))

(deftest test-n!-5
  (testing "Testing the n! function for the value 5"
    (is (= 120 (n! 5)))))

(deftest test-n!-5-fails
  (testing "Testing the n! function for the value 5 that fails"
    (is (= 121 (n! 5)))))
#+END_SRC

我们可以一次性运行所有的测试:

#+BEGIN_SRC clojure 
(run-tests)
#+END_SRC

#+BEGIN_EXAMPLE
Testing user

FAIL in (test-n!-5-fails) (form-init2702185496610974397.clj:25)
Testing the n! function for the value 5 that fails
expected: (= 121 (n! 5))
  actual: (not (= 121 120))

Ran 6 tests containing 6 assertions.
1 failures, 0 errors.
#+END_EXAMPLE

关于整合org-mode与clojure的原理,有些事情需要说明一下. 当在Org-mode文档中直接执行代码库时,所有的Clojure代码都是在Cider启动的一个名为 =user= 的命名空间内执行的.
当我们首先定义函数 =n!= 时,它实际上是定义在 =user= 这个命名空间中的, 然后我们定义的那些测试案例也是定义在那个命名空间中.
最后当我们不带任何参数调用 =run-tests= 时,它会运行当前命名空间中的测试案例,而当前命名空间又恰恰就是 =user= 这个命名空间.

由于每个代码块都是在相同的Clojure命名空间内执行的,这样一来,clojure能就与org-mode无缝整合起来了.
倘若我在后面又修改了这个函数,我可以直接在当前文档中重新发起测试,而无需切换到其他文件.

这就很有意思了,我们一边编写应用代码一边编写测试案例以保证应用代码的正确性. 我们还可以直接在开发文档中尽可能频繁地运行测试案例.
每次我保存Org-mode文档时,这些测试代码会被抽取出来保存为tests suites,然后在编译应用时被调用或者在其他需要运行测试时被调用.

使用Org-mode很爽的一点在于, 你可以通过按下 =C-c C-v b= 运行文档中的所有代码块, 这样一来你就在默认的命名空间内定义了所有的应用函数及其相应的测试案例, 而且当你运行那些包含测试的代码块时,你能立即看到测试的结果.

* Running One or Multiple Tests

It is often the case that you write a function and then want to test it right away. And then you write another
one and test it, too. You will end up with multiple code blocks where you want to test the inner test(s) and
get the results for those only.

With clojure.test we are limited in our options: we have run-tests and run-all-tests which provide a summary
report of the executed tests. Since Clojure 1.6 we have access to the test-vars function that we can use to
test one or multiple test cases. However, the usage of that function is a bit complex (in its syntax) and no
reporting is provided except if the tests fails.

So what I choose to do is to change this situation by creating a macro that greatly simplifies the code used
to run a specific set of tests and that reports failures and successes.

I created a really small and simple application for that purpose called [[https://github.com/structureddynamics/org-mode-clj-tests-utils][org-mode-clj-tests-utils]]. You can
easily use it in your Org-mode document just by making sure that the underlying project uses it.

Here is the macro. What it does is simply to take a series of symbols as input and use test-vars to run the
tests and then report failures and successes.

#+BEGIN_SRC clojure
(defmacro tests
  "Run one or multiple tests with fixtures. Returns successes or failures. 
   Tests should be in the same namespace."
  [& args]  
  `(binding [clojure.test/*test-out* (java.io.StringWriter.)]
     (clojure.test/test-vars [~@(mapv (fn [tname]
                                        `(var ~tname))
                                      args)])
     (if (empty? (str clojure.test/*test-out*))
       (println "All tests succeeded.")
       (println (str clojure.test/*test-out*)))))
#+END_SRC

Another option would be to define the tests in a specific namespace and then to use run-tests on that
namespace only. But that is cumbersome since you would have to use in-ns to define that new namespace and to
revert it back to the default namespace once you are done with the tests.

Now let’s see how this new macro can be used. Let’s say we just want to run the test test-n!-0:

#+BEGIN_SRC clojure 
(tests test-n!-0)
#+END_SRC

#+BEGIN_EXAMPLE
All tests succeeded.
#+END_EXAMPLE

Then let’s see what it looks like if a test fails:

#+BEGIN_SRC clojure 
(tests test-n!-5-fails)
#+END_SRC

#+BEGIN_EXAMPLE
FAIL in (test-n!-5-fails) (form-init2702185496610974397.clj:25)
Testing the n! function for the value 5 that fails
expected: (= 121 (n! 5))
  actual: (not (= 121 120))
#+END_EXAMPLE

Then we can run any number of tests:

#+BEGIN_SRC clojure 
(tests test-n!-0
       test-n!-1
       test-n!-2
       test-n!-5-fails)
#+END_SRC

#+BEGIN_EXAMPLE
FAIL in (test-n!-5-fails) (form-init2702185496610974397.clj:25)
Testing the n! function for the value 5 that fails
expected: (= 121 (n! 5))
  actual: (not (= 121 120))
#+END_EXAMPLE

As you can notice, the syntax for calling specific tests has been greatly simplified. We only have a write
tests followed by the name of the tests you want to test in that code block. Then every time you press C-c C-v
b you will re-run every code block of the document and all the results of the tests will be updated.

* Conclusion

Many people think that Literate Programming is only about typesetting and writing documents as books. However
I think this perception (or at least the general understanding) is wrong. I think the historic context of
Literate Programming influenced that perception but it is really much broader and important (at least to me)
than that. It is about the process of writing computer software, similar to the process of writing books,
articles, blog posts, etc., which includes documentation and testing, more than the task of simply coding.

Unit testing is one integral part of this process.

Note that you can take a look at the org-html-htmlize-output-type [[https://github.com/structureddynamics/org-mode-clj-tests-utils/blob/master/org/core.org][Org file to see a really simple example of a]]
[[https://github.com/structureddynamics/org-mode-clj-tests-utils/blob/master/org/core.org][Clojure Org-mode project]].
