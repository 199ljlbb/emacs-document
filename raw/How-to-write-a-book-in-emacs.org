#+TITLE: How-to-write-a-book-in-emacs
#+URL: https://www.masteringemacs.org/article/how-to-write-a-book-in-emacs                                  
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-12 五 17:18]
#+OPTIONS: ^:{}

写书是一件很耗时的事情,如果你打算花费一年或更多的时间在这上面,那你就有必要为此挑选一件称手的工具. 如果你是一名技术迷,而且刚好在用Emacs,那么这个选择是很明显的.

我最近才[[https://www.masteringemacs.org/book][才写完了一部书《Mastering Emacs》]] ,这里我想就如何用Emacs来写作一本书分享一下我的想法和观点.

* The traditional way

出版的传统模型中包括出版人,作者(就是你了),编辑以及(通常是)Microsoft Word. 非技术人员使用Word来写书有许多原因:

+ 它无处不在
   
  这样分享文档就很简单了,而且要找到安装了Word的电脑也很容易.
   
+ 出版人与编辑要求用它
   
  别人都用Word,因此即使你特别想用老旧的WordSTAR也不行. 他们只认Word格式的手稿.
   
+ 它的功能也够全
   
  Word其实也不错,它的拼写与语法检查功能很不错; 变更追踪与注解的功能也很方便; 它是所见即所得的,因此排版起来也很简单; 如果你想的话,甚至还能比较文档之间的区别.
   
具有讽刺意味的是,你写好书稿后,又会有人专门花时间把你的文本从Word中抽出来录入到Adobe InDesign中去. 跟搞笑的是,很多技术撰稿人使用Markdown,docbook或reStructureText格式来书写,然后直接把内容粘贴到Word了事.

不过这都不是重点.

重点在于,既然你写得是是关于Emacs的书,你又怎么能不用Emacs来写这本书呢? 还好,Emacs也确实很适合用来做这件事情.

* The Emacs Way

** Picking a source format

在我决定写这本书时,我希望能以ePub和PDF这两种格式来发布这本书. 我个人觉得技术类书籍比较适合以PDF格式发布或者打印出来看. 但是不是所有人都跟我一样这么热衷于PDF,因此我还得去寻找一个工具链来导出成ePub格式.

为了能以ePub和PDF的格式来发布此书,我的第一反应是使用LaTeX来写作. Indeed, the final PDF output is typeset with LaTeX. 但是LaTeX的格式太过诡异,并且将LaTeX转换成ePub的过程也很困难,我需要深入到低层来手工实现这个转换过程. 所以我放弃了用LaTeX来写书的打算.

最终我的选择是用reStructuredText格式来写作. 因为,作为一名Python开发者,我本身就会reStructredText格式了. 此外虽然Markdown格式要运用的更广泛的多,但我本身并不喜欢Markdown格式,因为它甚至都没有一个统一的语法. 

所以我的想法是,用reStructuredText格式来写作,然后用[[http://pandoc.org/][Pandoc]] 将之转换为ePub和LaTeX格式.

当然,我本来也可以直接用Org来写作的. 可惜Org mode很难与其他格式进行相互转换. 如果最终生成的格式是HTML的话,我可能会选择用Org格式来写作,但是最终生成的格式是LaTeX那就有太多的其他选择了.
而且,reStructuredText的格式也很清晰,并且若Pandoc无法完成转换工作的情况下,至少有docutils供我使用. 我可不想写到一半的时候不得不转换一种写作格式呢. 因此,最终我还是选择了reStructuredText.

#+BEGIN_SRC rst
  =============
   First Steps
  =============

  .. epigraph::

    I use Emacs, which might be thought of as a thermonuclear word processor.

    -- Neal Stephenson, *In the Beginning… was the Command Line*.

  ...

  In Emacs, there are several modifier keys you can use, each with its own character:

  ========   =========
  Modifier   Full Name
  ========   =========
  ``C-``     Control
  ``M-``     Meta ("Alt" on most keyboards)
  ``S-``     Shift
  ========   =========
#+END_SRC

上面是一段reStructuredText的示例,看起来很简洁,可读性很好,而且还能语法高亮.

** Proofreading and Tracking Changes

下一步,我要考虑校对的问题了. 我希望本书能够经过专业的编辑,因此我需要雇用一个编辑. 但是同时我又不想使用Microsoft Word.

最终我直接把原始的reStructuredText文件作为草稿发给编辑,然后让她按照自己的意愿随意修改草稿. 不需要追踪任何修订过程. 如果她需要添加注释只需要像下面那样在段落上插入注释就行了:

#+BEGIN_EXAMPLE
  SUE: You should consider rewriting this paragraph.

  When you use the command ``M-x toggle-truncate-lines`` [...]
#+END_EXAMPLE

不过她依然坚持要用Microsoft Word, 那我只要将原始的文本插入到Word中,调整为等宽字体,然后让她把Word中的自动跟正功能禁用掉(因为它会搞乱reStructuredText的格式).

[[https://www.masteringemacs.org/static/uploads/ediff.png]]

在她完成对草稿的修改后,我用Emacs的 =M-x ediff-buffers= 来对比校对后内容与原始草稿之间的区别,在效果上也也就等同于用diff来追踪修订的过程. 
你可能会好奇:那么哪些注释段落该怎么办呢?他们不是也会被diff监测出来吗? 是的,它们确实会被监测出来. 但是Emacs的ediff牛就牛在你可以让它隐藏匹配某一模式的区域,方法是在Ediff的控制frame中按下 ~#h~,然后输入下面这段正则表达式:

#+BEGIN_EXAMPLE
  ^SUE:
#+END_EXAMPLE

这样Emacs就会忽略以SUE开头的行了. 这样我不仅可以阅读编辑的注释并按照她的指导来修改我的草稿,还能合并她所做出的改动.
从上面的截图中你可能很难想象它是怎么工作的,而且有时候diff产生的结果可能太过于复杂了,但是这种情况所耗时间占总校对的时间很少.

还有一些小问题,比如有一些字符显示不太正常,因为我用的是UTF-8格式的编码,而她的Windows机器用的是iso-8859-1格式的编码. 不过要修正这个问题也容易,用个正则表达式替换就搞定了,两分钟的事,没什么问题.

因此,最终我能做到用reStructuredText写作,用reStructuredText校正,然后在Emacs中用ediff来修订它.

** Spell Checking

这部分工作我倒是挺怀念Microsoft Word的. 我用 =M-x flyspell-mode= 来追踪我输入的拼错的单词, 而且我调整了一下aspell(Emacs用来在后台进行拼写检查的命令行工具),让它使用美式英语而不是英式英语的方式来检查拼写:

#+BEGIN_SRC emacs-lisp
  .. -*- mode: rst; encoding: utf-8; ispell-dictionary: "american" -*-
#+END_SRC

但是aspell并不特别好用,用它来检查源码中的注释或README文件还好. 但是用来检查书籍的话,我发现很多地方它都检查不出来,而且它对连字符的监测规则也很糟糕. 
当然,总体来说aspell工作的还算可以,而且你在拼错的单词上按下 ~C-M-i~ 就能让Emacs自动修正该单词,这项功能还挺不错的.

** Jumping around

Helm提供了对imenu的支持,因此在章节之间跳转其实很容易. =M-x rst-mode= 本身就创建了一个关于所有章节位置的imenu索引,这让你在跨章节导航是十分便利.

** Pandoc

Pandoc确实很棒. 但是我在用的时候还是觉得麻烦不断. 首先是缺少文档. 目前能找到的文档只有一个man文件,一些浅显的例子以及一些零散的介绍基本用法的博客而已.
你可能会想:它只是个转换器而已,会需要多少文档呢? 我只能说,当你想查出为什么reStructedText中的某个样式为什么不能转换到LaTeX输出时,你就不会这么认为了.

最终我不得不深入源代码中找出为什么有的格式能转换,有的格式转换不出来. 最后得出的结论是,pandoc并不像markdown那样完全支持reStructuredText. pandoc甚至实现了自己的Markdown语法,称之为pandoc markdown.

这就很郁闷了. 不能完全对等的转换两种格式没有问题,但是至少也要告诉我们一下吧. 这样我也许在一开始就会换另一种格式来书写呢.

For instance, in reStructuredText you can annotate text with roles. There’s a handful in the specification,
but I wanted one for small caps, like so:

#+BEGIN_SRC rst
  :small-caps:`GNU`
#+END_SRC

I discovered Pandoc converts everything into a kind of Abstract Syntax Tree in JSON format. So I was thinking:
great, I’ll use Pandoc’s ability to call out to Python with each token from the AST and then hand-generate the
LaTeX (and HTML for ePub) that I need. Nope. Not gonna happen.

It turns out that Pandoc “helpfully” strips roles and directives that it doesn’t recognize. So I figured:
let’s hack the damn thing so it does what I need. But then I learn it’s written in Haskell. All right, I
thought, the parser’s clean and easy to understand, let’s get a Haskell dev environment set up. Cue 900 MB of
library cruft I had to download to even run the damn thing from source. I got flashbacks of bower, and npm,
and the entire JS ecosystem and decided, in the end, to bard the reStructuredText source file with custom
markers that I then map into LaTeX and HTML with sed.

Still, Pandoc’s a great tool, and I am glad it is there and that I got to use it. But although they support a
wide variety of formats you best steer clear of all but the most maintained ones. Were I do to this all over
again I would use docutils to spit out HTML (the LaTeX it generates is OK but not great) and then convert that
to my target formats.

** Outputting LaTeX

Or should I say, XeTeX. I needed XeTeX because the amount of METAFONT fonts available is vanishingly small.
XeTeX also supports unicode, which is rather important when you want a PDF format that is as close to plain
text as possible, for accessibility reasons.

XeTeX works great, and LaTeX is not a difficult thing to write. What is difficult is customizing LaTeX.
Enabling old-style numerals (lowercase numbers) is easy enough, right up until you want to only enable them in
some parts your book. Fact is, fiddling with LaTeX is time consuming but, to me, very important, so I spent
the time needed to make it look as good as I could.

LaTeX is a great typesetting system, and I could make the book look even better if I had focused solely on
PDF. As it stands, the lowest common denominator (ePub on Kindles, but more on that in a second) held it back.
I wanted fancier tables and numbered, vectorized arrows that shows how the point moves through text instead of
the simpler narrative format I adopted in the book. But I couldn’t do that in reStructuredText and Pandoc. A
shame. Having said that, I am very happy with the PDF output. On a High DPI screen the book looks fantastic
and I have received nothing but positive feedback so far.

** Outputting ePub

An ePub file is a zip file with a CSS file, an image of the book cover, a metadata file and a bunch of HTML
files. That’s it. And yet, I found it extremely hard to make it render properly on Kindles. To render HTML and
CSS you need a browser engine, and unsurprisingly the engines on a lot of Kindles out there are pretty
outdated and not very CSS compliant. Things like spacing between paragraphs instead of indented opening
paragraphs vary. I cannot stand indented paragraphs and I went out of my way to disable it in the PDF version
but it sadly lingers in some, but not all, Kindle readers. So converting to ePub is not a turnkey affair, even
though it certainly seems that way from the outset.

I’m glad I added ePub support but it was a lot of work to make it look okay on old versions and good on new
ones. So far, I’ve had no complaints. Touch wood.

** Compiling the books

I use a simple Makefile to generate the output formats and in the case of LaTeX the intermediate .tex file so
I can apply some sed scripts to it. From inside Emacs I used M-x compile to run the make command and display
the output. The Makefile itself was obviously authored in Emacs also.

Combined with inotifywait in a Makefile rule I could seamlessly update the final deliverables as I typed. In
the end I realized that I did not need that quick a turn-around on the output files as I am a habitual file
saver and did that far more frequently than I reviewed the output. I could also do it with a save hook (or
even an inotifywait hook) in Emacs.

With Emacs’s ability to browse PDF files I could review the book inside Emacs, next to the reStructuredText
file, which came in handy occasionally.

** General Editing

Throughout the course of writing the book I spent the entire time editing and moving and commands that work on
sentences (M-e, M-a, M-k) and paragraphs (M-{, M-}) came in handy often. Part of what made my book editing
less tedious was the elimination of superfluous stuff like fiddling with fonts and styling — a task relegated
to simple markup in reStructuredText and settings defined by me for the actual typesetting itself.

I often found myself abusing certain turns of phrases and Emacs’s custom highlighting M-s h p would highlight,
in garish black on yellow, such occurrences. The book was obviously stored in source control with Git and 
[[https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git][Magit]].

On the whole, the entirety of the book, from conception as a series of notes and TODOs in Org mode, to the
editing and merging of changes made by the proofreader took place in Emacs. The only tool I did not have in
Emacs was Amazon’s Kindle Previewer tool.

* Conclusion

Emacs is a great tool for book editing and writing. I used reStructuredText text but Markdown, ASCIIDoc,
Docbook or any number of formats would work equally well. Emacs’s ediff is a powerful diffing tool that made
it possible for me to track the changes made by the proofreader and selectively apply, but also edit, the
changes she made before committing them to the original manuscript. I think that feature alone made it worth
writing it in Emacs.
