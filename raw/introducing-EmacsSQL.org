#+TITLE: introducing-EmacsSQL
#+URL: http://nullprogram.com/blog/2014/02/06/                                                                                                                                                                 
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-07-04 一 07:34]
#+OPTIONS: ^:{}


昨天我release了第一版的 [[https://github.com/skeeto/emacsql][EmacSQL]]. 我为这个Emacs package已经花费了几周的时间了. EmacSQL 是一个Emacs上的高层SQL数据库抽象接口. 它主要使用SQLite作为后端,目前也支持PostgreSQL和MySQL.

该package可以[[http://melpa.milkbox.net/#/emacsql][通过MELPA安装]] ,并且安装好后立即就能用了. 它依赖于我上周才添加的[[http://nullprogram.com/blog/2014/01/27/][finalizers package]] .

虽然这个package依赖于一个非Elisp的组件,SQLite,但对于使用者来说,并不需要关心这个. 当编译该package的Elisp的时候,若系统已经安装了C编译器,则package会自动编译出SQLite执行程序共EmacsSQL使用. 否则,会自动下载我预编译好的SQLite执行程序. 理想情况下,EmacsSQL的这部分非Elisp组件可以对使用者完全透明,使用者完全可以认为Emacs已经内建了关系型数据库.

EmacsSQL不会去用SQLite的官方命令行程序(即使已经有了也不会取用),原因我会随后解释.

就好像[[http://nullprogram.com/blog/2012/10/31/][Skewer]] 使我接触到web开发一样, EmacSQL 让我快速学到了很多SQL与关系型数据库的知识. 在开始这个项目前,我对这个领域知之甚少, 但在开发这个项目的过程中,我学到了许多这方面的知识. 创建一个Emacs扩展真是进入一门新领域的快速途径.

如果你跟我一样完全是个新手,而你又想自学SQLite的SQL,我强烈推荐[[http://www.amazon.com/gp/product/0596521189/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596521189&linkCode=as2&tag=nullprogram-20][Using SQLite]]这篇文章. 这真是一篇入门精品.

* High-level SQL Compiler

所谓“high-level”意味着它会帮你拼接SQL语句. EmacSQL是根据一些简单的转换规则来将S表达式转化为SQL语句的. 也就是说,如果你已经懂得SQL了,你应该就能知道EmacsSQL的低层运行机理. 下面是一些例子,

#+BEGIN_SRC emacs-lisp
  (require 'emacsql)

  ;; Connect to the database, SQLite in this case:
  (defvar db (emacsql-connect "~/office.db"))

  ;; Create a table with 3 columns:
  (emacsql db [:create-table patients
                             ([name (id integer :primary-key) (weight float)])])

  ;; Insert a few rows:
  (emacsql db [:insert :into patients
                       :values (["Jeff" 1000 184.2] ["Susan" 1001 118.9])])

  ;; Query the database:
  (emacsql db [:select [name id]
                       :from patients
                       :where (< weight 150.0)])
  ;; => (("Susan" 1001))

  ;; Queries can be templates, using $s1, $i2, etc. as parameters:
  (emacsql db [:select [name id]
                       :from patients
                       :where (> weight $s1)]
           100)
  ;; => (("Jeff" 1000) ("Susan" 1001))
#+END_SRC

一个查询就是一个由关键字,标识符,参数和数据组成的数组. 这里参数的作用在于使得使用者无需在运行期动态地组建S表达式.

将S表达式编译成SQL语句的规则已经列在EmacsSQL的文档中了,我这里就不再重复了. 简单来说,lisp关键字会转换成SQL关键字, 基于行的信息(row-oriented information)使用数组来表示, 表达式使用list来表示, symbol没有被引用的话则会转换成标识符.

#+BEGIN_SRC emacs-lisp
  [:select [name weight] :from patients :where (< weight 150.0)]
#+END_SRC

会被编译成:

#+BEGIN_SRC sql
  SELECT name, weight FROM patients WHERE weight < 150.0;
#+END_SRC

另外, 任何[[http://nullprogram.com/blog/2013/12/30/#almost_everything_prints_readably][可读的lisp值]] 都能存储到数据库的属性中. 整数被映射出INTEGER型,小数被映射成REAL型, nil被映射为NULL,其他类型的值都以字面量的格式存储为TEXT类型. 当然这种映射关系根据后端的不同而改变.

* Parameters

以$开头的symbol被看成是参数. 紧跟$的是参数的类型 — identifier (i), scalar (s), vector (v), schema (S) — 最后是参数的位置.

#+BEGIN_SRC emacs-lisp
  [:select [$i1] :from $i2 :where (< $i3 $s4)]
#+END_SRC

若接受三个symbol以及1个整数作为参数: =name people age 21=, 则会编译成:

#+BEGIN_SRC sql
  SELECT name FROM people WHERE age < 21;
#+END_SRC

数组类型的参数引用的是带插入的行或者IN表达式中的集合.

#+BEGIN_SRC emacs-lisp
  [:insert-into people [name age] :values $v1]
#+END_SRC

若接受了一个由两行组成的list作为参数: =(["Jim" 45] ["Jeff" 34])=,则会编译成

#+BEGIN_SRC sql
  INSERT INTO people (name, age) VALUES ('"Jim"', 45), ('"Jeff"', 34);
#+END_SRC

还有这个例子:

#+BEGIN_SRC emacs-lisp
  [:select * :from tags :where (in tag $v1)]
#+END_SRC

若接受的参数为 =[hiking camping biking]=,则会编译成

#+BEGIN_SRC sql
  SELECT * FROM tags WHERE tag IN ('hiking', 'camping', 'biking');
#+END_SRC

当写这些S表达式时,记住可以使用命令 =emacsql-show-last-sql= 来在minibuffer中显示当前S表达式转换成的SQL语句是什么.

* Schemas

A table schema is a list whose first element is a column specification vector (i.e. row-oriented information is presented as vectors). The remaining elements are table constraints. Here are the examples from
the documentation,

#+BEGIN_SRC emacs-lisp
  ;; No constraints schema with four columns:
  ([name id building room])

  ;; Add some column constraints:
  ([(name :unique) (id integer :primary-key) building room])

  ;; Add some table constraints:
  ([(name :unique) (id integer :primary-key) building room]
   (:unique [building room])
   (:check (> id 0)))
#+END_SRC

In the handful of EmacSQL databases I’ve created for practice and testing, I’ve put the schema in a global constant. A table schema is a part of a program’s type specifications, and rows are instances of that
type, so it makes sense to declare schemas up top with things like defstructs.

These schemas can be substituted into a SQL statement using a $S parameter (capital “S” for Schema).

#+BEGIN_SRC emacs-lisp
  (defconst foo-schema-people
    '([(person-id integer :primary-key) name age]))

  ;; ...

  (defun foo-init (db)
    (emacsql db [:create-table $i1 $S2] 'people foo-schema-people))
#+END_SRC

* Back-ends

Everything I’ve discussed so far is restricted to the SQL statement compiler. It’s completely independent of the back-end implementations, themselves mostly handling strings of SQL statements.

* SQLite Implementation Difficulties

A little over a year ago I wrote [[http://nullprogram.com/blog/2012/12/29/][a pastebin webapp]] in Elisp. I wanted to use SQLite as a back-end for storing pastes but struggled to get the SQLite command shell, sqlite3, to cooperate with Emacs. The problem
was that all of the output modes except for “tcl” are ambiguous. This includes the “csv” formatted output. TEXT values can dump newlines, allowing rows to span an arbitrary number of lines. They can dump
things that look like the sqlite3 prompt, so it’s impossible to know when sqlite3 is done printing results. I ultimately decided the command shell was inadequate as an Emacs subprocess.

Recently there [[http://nullprogram.com/blog/2013/09/09/][was some discussion]] from alexbenjm and Andres Ramirez on an Elfeed post about using SQLite as an Elfeed back-end. This inspired me to take another look and that’s when I came up with a
workaround for SQLite’s ambiguity: only store printed Elisp values for TEXT values! With print-escape-newlines set, TEXT values no longer span multiple lines, and I can use read to pull in data from sqlite3.
All of sqlite3’s output modes were now unambiguous.

However, after making significant progress I discovered an even bigger issue: GNU Readline. The sqlite3 binary provided by Linux package repositories is almost always compiled with Readline support. This makes
the tool much more friendly to use, but it’s a huge problem for Emacs.

First, sqlite3 the command shell is not up to the same standards as SQLite the database. Not by a long shot. In my short time working with SQLite I’ve already discovered several bugs in the command shell. For
one, it’s not properly integrated with GNU Readline. There’s an .echo meta-command that turns command echoing on and off. That is, it repeats your command back to you. Useful in some circumstances, though not
mine. The bug is that this echo is separate from GNU Readline’s echo. When Readline is active and .echo is enabled, there are actually two echos. Turn it off and there’s one echo.

* Pseudo-terminals

Under some circumstances, like when communicating over a pipe rather than a PTY, Readline will mostly become deactivated. This would have been a workaround, but when Readline is disabled sqlite3 heavily
buffers its output. This breaks any sort of interaction. Even worse, on Windows [[http://sqlite.1065341.n5.nabble.com/Command-line-shell-not-flushing-stderr-when-interactive-td73340.html][stderr is not always unbuffered]], so sqlite3’s error messages may not appear for a long time (another bug).

Besides the problem of getting Readline to shut up, another problem is getting Readline to stop acting on control characters. The first 32 characters in ASCII are control characters. A pseudo-terminal (PTY)
that is not in raw mode will immediately act upon any control characters it sees. There’s no escaping them.

Emacs communicates with subprocesses through a PTY by default (probably an early design mistake), limiting the kind of data that can be transmitted. You can try this yourself in a comint mode sometime where a
subprocess is used (not a socket like SLIME). Fire up M-x sql-sqlite (part of Emacs) and try sending a string containing byte 0x1C (28, file separator). You can type one by pressing C-q C-\. Send that byte and
the subprocess dies.

There are two ways to work around this. One is to use a pipe (bind process-connection-type to nil). Pipes don’t respond to control characters. This doesn’t work with sqlite3 because of the previously-mentioned
buffering issue.

The other way to work around this is to put the PTY in raw mode. Unfortunately there’s no function to do this so you need to call stty. Of course, this program needs to run on the same PTY, so a
start-process-shell-command is required.

#+BEGIN_SRC emacs-lisp
  (start-process-shell-command name buffer "stty raw && <your command>")
#+END_SRC

Windows has neither stty nor PTYs (nor any of PTY’s issues) so you’ll need to check the operating system before starting the process. Even this still doesn’t work for sqlite3 because Readline itself will
respond to control characters. There’s no option to disable this.

There’s a package called [[https://github.com/mhayashi1120/Emacs-esqlite][esqlite]] that is also a SQLite front-end. It’s built to use sqlite3 and therefore suffers from all of these problems.

* A Custom SQLite Binary

Since sqlite3 proved unreliable I developed my own protocol and external program. It’s just a tiny bit of C that accepts a SQL string and returns results as an s-expression. I’m not longer constrained to
storing readable values, but I’m still keeping that paradigm. First, it keeps the C glue program simple and, more importantly, I can rely entirely on the Emacs reader to parse the results. This makes
communication between Emacs and the subprocess as fast as it can possibly be. The reader is faster than any possible Elisp program.

As I mentioned before, this C program is compiled when possible, and otherwise a pre-built binary is fetched from my server (popular platforms only, obviously). It’s likely EmacSQL will have at least one
working back-end on whatever you’re using.

* Other Back-ends

Both PostgreSQL and MySQL are also supported, though these require the user have the appropriate client programs installed (psql or mysql). Both of these are much better behaved than sqlite3 and, with the stty
trick, each can reliably be used without any special help. Both pass all of the unit tests, so, in theory, they’ll work just as well as SQLite.

To use them with the example at the beginning of this article, require emacsql-psql or emacsql-mysql, then swap emacsql-connect for the constructors emacsql-psql or emacsql-mysql (along with the proper
arguments). All three of these constructors return an emacsql-connection object that works with the same API.

EmacSQL only goes so far to normalize the interfaces to these databases, so for any non-trivial program you may not be able to swap back-ends without some work. All of the EmacSQL functions that operate on
connections are generic functions (EIEIO), so changing back-ends will only have an effect on the program’s SQL statements. For example, if you use q SQLite-ism (dynamic typing) it won’t translate to either of
the other databases should they be swapped in.

I’ll cover the connections API, and what it takes to implement a new back-end, in a future post. Outside of the PTY caveats, it’s actually very easy. The MySQL implementation is just 80 lines of code.

* EmacSQL’s Future

I hope this becomes a reliable and trusted database solution that other packages can depend upon. Twice so far, the pastebin demo and Elfeed, I’ve really wanted something like this and, instead, ended up
having to hack together my own database.

I’ve already started a branch on Elfeed re-implementing its database in EmacSQL. Someday it may become Elfeed’s primary database if I feel there’s no disadvantage to it. EmacSQL builds SQLite with the
full-text search engine enabled, which opens to the door to a powerful, fast Elfeed search API. Currently the main obstacle is actually Elfeed’s database API being somewhat incompatible with ACID database
transactions — shortsightedness on my part!
