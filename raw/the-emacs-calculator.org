#+TITLE: the-emacs-calculator
#+URL: http://nullprogram.com/blog/2009/06/23/                                                              
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-07-06 三 11:04]
#+OPTIONS: ^:{}

你知道[[http://www.gnu.org/software/emacs/calc.html][Emacs自带有一个计算器吗]]? Woop-dee-doo! Call the presses! Wow, a whole calculator!
Sounds a bit lame, right?

事实上, 这可不仅仅是个简单的计算机而已, 这是一个[[http://en.wikipedia.org/wiki/Computer_algebra_system][计算机代数系统]]! 虽说官方只是称呼它为一个计算器,但这只是一种谦虚的说法,我想恐怕有很多人因此而忽视了它. 
我自己也是在通读Emacs manual时才发现它的,而且当时也差点略过了它.

你有看过几年前Will Wright为孢子游戏所做的展示么? 玩家一开始只是个单细胞生物,后来发展出一个横跨星际的文明. 
Will Wright开始时只展示了一个显微镜下的系统. 没人知道这个什么样的游戏,而随着尺度的增加,从细菌到动物,从动物到出现文明,从出现文件到实现太空旅行,在星际间旅行到星系间旅行,引起了观众一次次的强烈反响.
就像它的广告语说的:"还没完呢!!!"

随着我不断的深入Emacs calc manual,我一次次的感叹于它的功能之强. 每一页说明都在告诉我:"还没完呢!!!".

我这里仅仅对对其的某些特征进行讲解. 要想获得一个全面的了解,你需要阅读calc manual. manual中甚至还有一些练习来展示一些陷阱和一些有趣的特征交互.

按下 =C-x * c= 或 =M-x calc= 启动calc. 会显示出两个新窗口(Emacs中的窗口),一个是计算器,另一个显示操作历史.

首先,这个计算器是基于栈操作的,它的基础用法是采用逆波兰表示法. 栈垂直向下生长. 输入数字然后回车就会将数字入栈. 输入数字后也可以直接输入运算符而无需每次都回车.
由于减号(-)被用于表示减法运算符,因此使用下划线(_)来表示负数. 下面是一个例子,依次入栈3, 4, 10:

#+BEGIN_EXAMPLE
  3:  3
  2:  4
  1:  10
      .
#+END_EXAMPLE

10位于栈顶(因此它的前面的编号为"1:"), 当我们输入 =*= 时,最顶部的两个元素会相乘:

#+BEGIN_EXAMPLE
  2:  3
  1:  40
      .
#+END_EXAMPLE

calc支持无限长度的整型,因此你可以使用超大的数而不会有精度丢失. 例如我们计算一下2^200:

#+BEGIN_EXAMPLE
  2:  2
  1:  200
      .
#+END_EXAMPLE

按下 =^=,

#+BEGIN_EXAMPLE
  1:  1606938044258990275541962092341162602522202993782792835301376
      .
#+END_EXAMPLE

还没完!!! Calc支持复数,方法是将实部与虚部成对放入括号内,像这样 =(real, imaginary)=. 可以对复数进行任意运算,就跟其他数一样. 例如计算 ~-1 + 2i~ 减去 ~4 + 2i~,

#+BEGIN_EXAMPLE
  2:  (-1, 2)
  1:  (4, 2)
      .
#+END_EXAMPLE

按下 =-= 作减法,

#+BEGIN_EXAMPLE
  1:  -5
      .
#+END_EXAMPLE

然后按下 =Q= 调用平方根函数计算平方根.

#+BEGIN_EXAMPLE
  1:  (0., 2.2360679775)
      .
#+END_EXAMPLE

你还可以按下 =p= 来设置计算的精度. 默认精度为12位. 例如计算 ~1 / 7~:

#+BEGIN_EXAMPLE
  1:  0.142857142857
      .
#+END_EXAMPLE

我们将精度调整为50位后,再计算一次:

#+BEGIN_EXAMPLE
  2:  0.142857142857
  1:  0.14285714285714285714285714285714285714285714285714
      .
#+END_EXAMPLE

数字能以各种计数法的方式来表示,例如定点计数法,科学计数法,工程计数法. 可以在不同计数法之间切换而不会丢失任何信息(数的存储与显示是独立的).

还没完呢!!! 我们还可以用分数的形式表示有理数. 格式是 =分子:分母=.

#+BEGIN_EXAMPLE
  3:  1:7
  2:  3:13
  1:  17:29
      .
#+END_EXAMPLE

它们的累积以最低层的形式来显示(And multiply them all together, which displays in the lowest form),

#+BEGIN_EXAMPLE
  1:  51:2842
      .
#+END_EXAMPLE

There is a mode for working in these automatically.

还没完呢!!! 我们还能修改基数. 要输入一个其他基数的数字,只需要以基数和 =#= 为前缀即可. 例如我们是这样输入以2为积的29的:

#+BEGIN_EXAMPLE
  2#11101
#+END_EXAMPLE

可以通过 =d r= 修改显示的基数. 例如假设栈中的数字为29(10进制),则转换成以4为基数则是:

#+BEGIN_EXAMPLE
  1:  4#131
      .
#+END_EXAMPLE

转换为16进制为:

#+BEGIN_EXAMPLE
  1:  16#1D
      .
#+END_EXAMPLE

转换为36进制为:

#+BEGIN_EXAMPLE
  1:  36#T
      .
#+END_EXAMPLE

还没完呢!!! 我们也可以直接输入代数表达式,方法是以单引号(')开头. 表达式中甚至还可以带符号. 
注意: 这些表达式不是以逆波兰表示法录入的.

#+BEGIN_EXAMPLE
  1:  a^3 + a^2 b / c d - a / b
      .
#+END_EXAMPLE

按下 =d B= 可以进入"big"模式,在此模式下更易阅读:

#+BEGIN_EXAMPLE
              2
       3   b a    a
  1:  a  + ---- - -
           c d    b


      .
#+END_EXAMPLE

我们还可以为变量赋值来计算表达式. 例如使用 "evaluates-to" 运算符将a的值赋为10可以得到下列结果:

#+BEGIN_EXAMPLE
            2
       3   a  b   a             100 b   10
  1:  a  + ---- - -  =>  1000 + ----- - --
           c d    b              c d    b

      .
#+END_EXAMPLE

还没完呢!!! There is a vector type for working with vectors and matrices and doing linear algebra.
They are entered with brackets, [].

#+BEGIN_EXAMPLE
  2:  [4, 1, 5]
  1:  [ [ 1, 2, 3 ]
        [ 4, 5, 6 ]
        [ 6, 7, 8 ] ]
      .
#+END_EXAMPLE

And take the dot product, then take cross product of this vector and matrix,

#+BEGIN_EXAMPLE
  2:  [38, 48, 58]
  1:  [ [ -14, -18, -22 ]
        [ -19, -18, -17 ]
        [ 15,  18,  21  ] ]
      .
#+END_EXAMPLE

Any matrix and vector operator you could probably think of is available, including map and reduce (and you can
define your own expression to apply).

We can use this to solve a linear system. Find x and y in terms of a and b,

#+BEGIN_EXAMPLE
  x + a y = 6
  x + b y = 10
#+END_EXAMPLE

Enter it (note we are using symbols),

#+BEGIN_EXAMPLE
  2:  [6, 10]
  1:  [ [ 1, a ]
        [ 1, b ] ]
      .
#+END_EXAMPLE

And divide,

#+BEGIN_EXAMPLE
            4 a     4
  1:  [6 + -----, -----]
           a - b  b - a

      .
#+END_EXAMPLE

还没完呢!!! We can create graphs if gnuplot is installed. We can give it two vectors, or an
algebraic expression. This plot of sin(x) and x cos(x) was made with just a few keystrokes,

[[http://nullprogram.com/img/emacs/calc-plot.png]]

还没完呢!!! There is an HMS type for handling times and angles. For 2 hours, 30 minutes, and 4
seconds, and some others,

#+BEGIN_EXAMPLE
  3:  2@ 30' 4"
  2:  4@ 22' 13"
  1:  1@ 2' 56"
      .
#+END_EXAMPLE

Of course, the normal operators work as expected. We can add them all up,

#+BEGIN_EXAMPLE
  1:  7@ 55' 13"
      .
#+END_EXAMPLE

We can convert between this and radians, and degrees, and so on.

还没完呢!!! The calculator also has a date type, entered inside angled brackets, <> (in algebra
entry mode). It is really flexible on input dates. We can insert the current date with t N.

#+BEGIN_EXAMPLE
  1:  <6:59:34pm Tue Jun 23, 2009>
      .
#+END_EXAMPLE

If we add numbers they are treated as days. Add 4,

#+BEGIN_EXAMPLE
  1:  <6:59:34pm Sat Jun 27, 2009>
      .
#+END_EXAMPLE

It works with the HMS format from before too. Subtract 2@ 3' 15".

#+BEGIN_EXAMPLE
  1:  <4:56:32pm Sat Jun 27, 2009>
      .
#+END_EXAMPLE

还没完呢!!! There is a modulo form for performing modulo arithmetic. For example, 17 mod 24,

#+BEGIN_EXAMPLE
  1:  17 mod 24
      .
#+END_EXAMPLE

Add 10,

#+BEGIN_EXAMPLE
  1:  3 mod 24
      .
#+END_EXAMPLE

This is most useful for forms such as n^p mod M, which this will handle efficiently. For example, 3^100000 mod
24. The naive way would be to find 3^100000 first, then take the modulus. This involves a computationally
expensive middle step of calculating 3^100000, a huge number. The modulo form does it smarter.

还没完呢!!! The calculator can do unit conversions. The version of Emacs (22.3.1) I am typing in
right now knows about 159 different units. For example, I push 65 mph onto the stack,

#+BEGIN_EXAMPLE
  1:  65 mph
      .
#+END_EXAMPLE

Convert to meters per second with u c,

#+BEGIN_EXAMPLE
  1:  29.0576 m / s
      .
#+END_EXAMPLE

It is flexible about mixing type of units. For example, I enter 3 cubic meters,

#+BEGIN_EXAMPLE
         3
  1:  3 m

      .
#+END_EXAMPLE

I can convert to gallons,

#+BEGIN_EXAMPLE
  1:  792.516157074 gal
      .
#+END_EXAMPLE

I work in a lab without Internet access during the day, so when I need to do various conversions Emacs is
indispensable.

The speed of light is also a unit. I can enter 1 c and convert to meters per second,

#+BEGIN_EXAMPLE
  1:  299792458 m / s
      .
#+END_EXAMPLE

还没完呢!!! As I said, it's a computer algebra system so it understands symbolic math. Remember
those algebraic expressions from before? I can operate on those. Let's push some expressions onto the stack,

#+BEGIN_EXAMPLE
  3:  ln(x)

         2   a x
  2:  a x  + --- + c
              b

  1:  y + c

      .
#+END_EXAMPLE

Multiply the top two, then add the third,

#+BEGIN_EXAMPLE
                  2   a x
  1:  ln(x) + (a x  + --- + c) (y + c)
                       b

      .
#+END_EXAMPLE

Expand with a x, then simplify with a s,

#+BEGIN_EXAMPLE
                   2   a x y              2   a c x    2
  1:  ln(x) + a y x  + ----- + c y + a c x  + ----- + c
                         b                      b

      .
#+END_EXAMPLE

Now, one of the coolest features: calculus. Differentiate with respect to x, with a d,

#+BEGIN_EXAMPLE
      1             a y             a c
  1:  - + 2 a y x + --- + 2 a c x + ---
      x              b               b

      .
#+END_EXAMPLE

Or undo that and integrate it,

#+BEGIN_EXAMPLE
                         3      2                  3        2
                    a y x    a x  y           a c x    a c x       2
  1:  x ln(x) - x + ------ + ------ + c x y + ------ + ------ + x c
                      3       2 b               3       2 b

      .
#+END_EXAMPLE

That's just awesome! That's a text editor ... doing calculus!

So, that was most of the main features. It was kind of exhausting going through all of that, and I am only
scratching the surface of what the calculator can do.

Naturally, it can be extended with some elisp. It provides a defmath macro specifically for this.

I bet (hope?) someday it will have a functions for doing Laplace and Fourier transforms.
