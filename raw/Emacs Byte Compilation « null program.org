#+URL: http://nullprogram.com/blog/2010/07/01/

某些Lisp有一项独门绝迹,那就是可以在任意时刻将函数编译成字节码/本地代码(具体编译成什么有赖于方言和具体实现).
对于那些能够编译的Lisp函数(例如[[http://clisp.cons.org/][CLISP]]), 一般都支持两种形式的代码: 一种是缓慢的,未优化未编译过的代码,一种是快速,高效编译过的代码.
但是你不要以为未编译的代码就一无是处了,除了无需花费时间在编译上之外,它也有其他的有点.

对于Emacs Lisp来说, 未编译过的函数就是一个lambda表达式. 只不过它存在于一个symbol中,就相当与给它取了个名字.
而编译后的form则是一个(特殊的)数组, 编译后的字节码以字符串的形式存在这个数组的第二个元素中. 其他的元素还包括常量,docstring等.
Elisp提供了 =byte-compile= 函数来编译其他函数. 该函数能接受一个lambda函数或者一个symbol. 
不过如果参数是symbol的话,编译后的函数回覆盖该symbol的原S表达式.

#+BEGIN_SRC emacs-lisp
  (byte-compile (lambda (x) (* 2 x)))
  => #[(x) "^H\301_\207" [x 2] 2]
#+END_SRC

编译器不仅仅是将函数是转换成字节码并展开宏,还会进行一些优化,比如删除无用代码,预先执行 safe constant forms, 以及内联函数. 从而极大地提高执行效率.
(通过我的 [[http://nullprogram.com/blog/2009/05/28/][measure-time macro]] 来测算的)

#+BEGIN_SRC emacs-lisp
  (defun fib (n)
    "Fibonacci sequence."
    (if (<= n 2) 1
      (+ (fib (- n 1)) (fib (- n 2)))))

  (measure-time
   (fib 30))
  => 1.0508708953857422

  (byte-compile 'fib)

  (measure-time
   (fib 30))
  => 0.4302399158477783
#+END_SRC

Most of the installed functions in a typical Emacs instance are already
compiled, since they are loaded already compiled. But a number of them aren't
compiled. So, I thought, why not spend a few seconds to do this?

In Common Lisp, there is a predicate for testing whether a function has been
compiled or not: compiled-function-p. For whatever reason, there is no
equivalent predefined in Elisp, so I wrote one,

#+BEGIN_SRC emacs-lisp
  (defun byte-compiled-p (func)
    "Return t if function is byte compiled."
    (cond
     ((symbolp   func) (byte-compiled-p (symbol-function func)))
     ((functionp func) (not (sequencep func)))
     (t nil)))
#+END_SRC

My idea was to iterate over every interned symbol and, if the function slot
contains an uncompiled function, using the test above, I would call
byte-compile on it. Well, it turns out that byte-compile is very flexible and
will ignore symbols with no function and symbols with already compiled
functions.

So next, how do we iterate over every interned symbol? There is a mapatoms
function for this. Provide it a function and it calls it on every interned
symbol. Well, that's simple and anticlimactic.

#+BEGIN_SRC emacs-lisp
  (mapatoms 'byte-compile)
#+END_SRC

That's it! It will take only a few seconds and spew a lot of warnings. I
haven't found a way to disable those warnings, so this isn't something you'd
want to have run automatically, unless you like having an extra window thrown
in your face. I've only discovered this recently, so I'm not sure what sort of
bad things this may do to your Emacs session. Not every function was written
with compilation in mind. There are interactions with macros to consider.

I doubt there will be a noticeable performance difference. Like I said before,
most everything is already compiled, and those are the functions that get used
the most. There's just something nice about knowing all your functions are
compiled and optimized.
