#+TITLE: Keep-in-secrets-in-Emacs-with-GnuPG-and-Auth-Source
#+URL: https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources                   
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-12 五 17:30]
#+OPTIONS: ^:{}


用明文存储机密信息可不好. 若你非常在意你的机密(若你已经被监控起来了,那么你怎么在意都不过分),则这篇文章中的建议恐怕还远远不能满足你的需求;
但是对于大多数人来说,用加密的文件来保存机密信息已经足够安全了.

自然,Emacs有多种方式为你加密.

Emacs原生支持GnuPG加密.借助一个名为EasyPG的package(或者缩写为epa)可以对文件进行加签/验证,加密/解密等操作.
我还会告诉你如何使用auth-source这个package(它为不同的加密后端提供了一个统一的接口)来对自动登录到各种外部服务上去(需要设置公私密钥).

* Keeping Secrets in Emacs with GnuPG & EasyPG

GNU Privacy Guard ([[https://www.gnupg.org/][GnuPG]])是OpenPGP标准的一个实现. 它十分的强大,同时支持对称加密与非对称加密. 你可以用它对对二进制文件或归档文件进行签名,用非对称密钥对文件进行加解密,也可以用对称加密的方法对文件进行加密.
GPG,你值得拥有.

而且GnuPG也与Emacs整合的很好,Emacs内建了一个名为EasyPG的package,可以提供基本的GnuPG功能.

你即能用EasyPG来对文件加签,也能用它来验签,即能用为对文件加密也能用来解密,而且同时支持对称和非对称加解密. 

* GPG v1 versus GPG v2

若你使用EasyPG时发生错误,告诉你找到gpg程序,那通常是因为你安装的是第二版的GPG,它的文件名是gpg2. 你可以设置一下 =epg-gpg-program= 的值:

#+BEGIN_SRC emacs-lisp
  (setq epg-gpg-program "gpg2")
#+END_SRC

* Transparent File Cryptography with EasyPG

EasyPG最好用的一个功能是它会在你打开文件时自动解密,然后在保存是自动加密,整个过程对你来说是透明的.

EasyPG package会添加几个hook到Emacs,它会自动地探测一个文件是否为GnuPG加密过的文件. 变量 =auto-mode-alist= 决定了Emacs打开某个文件时会进入哪个major mode. 在我这,以 =.gpg= 结尾的文件被认为是经过GnuPG加密过的文件.

你可以测试一下,打开一个文件(例如 =/tmp/foobar.gpg=),写入一些内容,在按下 =C-x C-s= 保存它. 会发现Emacs提示你选择一个密钥来加密,如果你没有选择任何密钥,则会提示你输入用于对称加密的密码.

然后你再重新打开这个文件,会发现Emacs提示你输入上次加密时的密码,然后Emacs会对文件进行解密并打开它.

不仅如此,它还支持嵌套的文件扩展名: 例如打开一个名为 =.py.gpg= 的文件,Emacs会先对它进行解密然后用普通的python-mode打开它. 对加密后的压缩过的归档文件也是一样,打开后缀为 =.tar.gz.gpg= 的文件,Emacs会先解密然后用auto-compression-mode打开它.

* Interactive Commands

EasyPG有一些方便的快捷键:

Command                       Description                                     
M-x epa-list-keys             列出所有私钥/公钥
M-x epa-list-secret-keysList 
M-x epa-verify-<region|file>  校验当前region/文件
M-x epa-sign-<region|file>    对当前region/文件加签
M-x epa-insert-keys           在buffer中插入一个或多个密钥
M-x epa-decrypt-<region|file> 解密当前region/文件
M-x epa-encrypt-<region|file> 加密当前region/文件

大多数的命令命名方式都准照一定模式,并且他们的功能也很直观. =M-x epa-list-keys= 和 =M-x epa-list-secret-keys= 都会列出你系统中密钥链中的密钥. 
你也可以用Emacs Secrets package (下面会说到)或系统自带的工具(例如Ubuntu的seahorse)来查看这些密钥.

* Dired

借助Emacs巧妙的auto-mode-alist体系,你可以在Dired中直接打开.gpg文件,跟你在其他地方打开.gpg文件没什么两样. 不过Dired还为EasyPG提供了一些好用的快捷键:

| Key Binding | Description                |
|-------------+----------------------------|
| : d         | Decrypt marked or selected |
| : e         | Encrypt marked or selected |
| : s         | Sign marked or selected    |
| : v         | Signs the current buffer   |

如果你为多个文件加了标注,则Dired会应用命令到这些文件上,否则会应用命令到光标所在的文件上.

要注意:如果你想将多个文件加密成一个.gpg文件,你需要先把这些文件压缩成一个文件:
标注好要被压缩的文件,在按下 =c=,然后输入要压缩成的目标文件名. Emacs就会根据目标文件的文件扩展名(.tar.gz, .zip等等)自动选择合适的压缩命令去压缩这些文件,然后你就可以对产生的压缩表进行加密了.

* Disabling External Pin Entry

你可以强制让GPG不要用外部工具来读取密码(pin entry). 这在你不希望启用默认的GPG Agent pin entry工具,而希望Emacs来为你管理pin entry时尤其有用.

有很多中方法都能做到这一步(具体的方法跟你的distro 与 window manager有关),不过最简单的方法就是只在Emacs中禁用agent info. 方法是执行下面代码:

#+BEGIN_SRC emacs-lisp
  (setenv "GPG_AGENT_INFO" nil)
#+END_SRC

这会强制让Emacs用它自己的内部密码提示功能而不会调用外部的pin entry程序.

* Using Keys to Store Secrets

NOTE: Please keep in mind that you are taking security advice from an Emacs blogger and not a security maven.
The instructions below are just a guideline to show you how to use Emacs’s GPG integration.

Like I mentioned above, it’s easy to transparently decrypt and encrypt files with a symmetric key but that’s
an awful lot of hassle when you can use a public-private key pair instead. The benefit of the key is that you
can keep it loaded into memory and let Emacs decrypt and re-encrypt files without prompting you for a
password.

* Creating a key

To get started you must first generate the key pair with gpg:

#+BEGIN_SRC sh
  gpg --gen-key
#+END_SRC

Follow the prompts to generate your key. I highly recommend you pick a pass phrase!

You can verify it is loaded into your system’s keychain by running:

M-x epa-list-secret-keys in Emacs;

or gpg --list-secret-keys on your command line, in which case it’ll look like this:

#+BEGIN_EXAMPLE
  $ gpg --list-secret-keys

  sec   2048R/5DB69AC1 2016-06-13
  uid                  Cosmo Kramer (Kramerica Industries) <kramer@example.com>
  ssb   2048R/02A89A28 2016-06-13
#+END_EXAMPLE

or using a UI program like seahorse.

* Exporting and Re-Importing a Key

Next, export the secret key to a file mykey.asc to gpg (using the key holder’s name, email or key ID):

#+BEGIN_SRC sh
  gpg --armor --export-secret-keys Cosmo Kramer > mykey.asc
#+END_SRC

You can now, on a different machine, re-import the key, but you will also have to trust it again. You can pass
the full name in quotes or the e-mail to gpg and it will pick the right one. Here I edit a key based on the
full name of the key holder and GPG is smart enough to figure out which one it is:

#+BEGIN_EXAMPLE
  $ gpg --import mykey.asc
  $ gpg --edit-key "Cosmo Kramer"
  gpg> trust
  Your decision? 5
  Do you really want to set this key to ultimate trust? (y/N) y
  gpg> quit
#+END_EXAMPLE

At this point you have a key and a way of exporting and re-importing it between computers; useful, if you use
more than one, but optional. It goes without saying that if you lose your key you lose your encrypted data!

* Encrypting Data with a Key

Armed with a key you can tell EasyPG that it should simply decrypt and re-encrypt with the secret keys in your
keychain. There’s a special file local variable called epa-file-encrypt-to that automatically picks the right
key.

Here’s a simple example. Create an elisp file your-secrets.el and enter the following:

#+BEGIN_SRC emacs-lisp
  # -*- epa-file-encrypt-to: ("kramer@example.com") -*-

  (setq jabber-account-list ...)
  (setq my-secret-password "rosebud")
#+END_SRC

Where kramer@example.com is the example key we created earlier and the e-mail “recipient” we encrypt and
decrypt against. Observe that we are finding a key based on the e-mail address alone as it’s human readable as
opposed to an ID. Next, explicitly encrypt it with M-x epa-encrypt-file and select the same key to encrypt
with. When you try to save the encrypted file Emacs will automatically pick the right key.

Now you can load the file in your init.el when you load Emacs:

#+BEGIN_SRC emacs-lisp
  (load-library "/path/to/your-secrets.el.gpg")
#+END_SRC

Emacs will ask for a pass phrase of the key it was encrypted with and then load the elisp file as though it
were a normal file.

* Storing Credentials with the Auth Source Package

This chapter builds on information in the section Using Keys to Store Secrets.

Auth Source is a generic interface for common backends such as your operating system’s Keychain and your local
~/.authinfo or ~/.netrc file.

Auth Source is supported by a variety of Emacs packages, but with the added benefit of having a fairly
straightforward API if you do need to call it directly. Among the supported ones are: jabber.el, GNUS, TRAMP,
various internal network functions, LDAP (yes, Emacs has an LDAP client built in), and ERC.

Auth Source solves the problem of mapping passwords and usernames to hosts, and it even supports multiple
backends if you have credentials in more than one place.

* Debugging Authentication Issues

The first thing I want to mention is the debug variable. Debugging authentication problems is hard enough
without adding another layer inbetween. To enable debug information set the auth-source-debug to t to enable
or nil to disable:

#+BEGIN_SRC emacs-lisp
  (setq auth-source-debug t)
#+END_SRC

This will echo a lot of additional, helpful, information to the *Messages* buffer. Be sure to turn it off when
you are done.

Another useful function to call is M-x auth-source-forget-all-cached. Auth source will cache your credentials
in Emacs; use this command to forget all the cached details.

* Automatic Jabber Login

Here’s a common workflow: logging in to Google Hangouts/Chat with jabber.el.

Consider the following jabber account:

#+BEGIN_SRC emacs-lisp
  (setq jabber-account-list
        '(("<your-gmail-email>"
           (:network-server . "talk.google.com")
           (:port . 443)
           (:connection-type . ssl))))
#+END_SRC

When you run M-x jabber-connect you’ll be asked – if all goes well – for your password. Instead of having to
type it every time you can store it encrypted on your filesystem and have Emacs fill it in automatically.

To do this we’ll need an .authinfo file and a way of telling Emacs where it is. By default it will look in ~
/.authinfo and a few other places, but I prefer keeping it encrypted and under source control. So to tell
auth-source where to look for it you update the auth-sources list variable:

#+BEGIN_SRC emacs-lisp
  (setq auth-sources
        '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
#+END_SRC

Change the filepath to one that works for you. Next, create the empty file as .authinfo.gpg and add this line:

#+BEGIN_EXAMPLE
  machine gmail.com login <your account name> port xmpp password <your secret password>
#+END_EXAMPLE

Replacing <your account name> with the username only – i.e., johndoe and not johndoe@gmail.com. Replace <your
secret password> with your password and save the file and pick the key you created earlier.

Ensure the auth-sources variable is set up and evaluated and then run M-x jabber-connect again and – if you’ve
set it up right – Emacs will decrypt your .authinfo.gpg file – prompting you for your passphrase, once, if
Emacs does not have the secret key in memory – and match the hostname and username against the entries in
.authinfo.gpg and send the password to Jabber.

And if things go wrong, refer to the Debugging Authentication Issues chapter above.

Now you can go ahead and extend this to your e-mails, to TRAMP (if you don’t use SSH keys) and so on applying
the same principles. Emacs will keep the secret key in memory and apply it automatically and you won’t be
badgered to enter a password over and over again any more.

One more useful thing about the auth-sources variable: you can have more than one source. You can even use
your OS’s keychain/agent as a source of keys.

* Conclusion

Good news – your Vogon poetry’s safe. As you can see, with a bit of technical kowtowing with GPG and Emacs’s
authentication machinery and you can automate away most of the tedium of credentials management. EasyPG and 
Auth Sources are both powerful tools that you should learn more about. In fact, I’ve barely scratched the
surface and, like all things Emacs, everyone has their own special snowflake configuration so do let me know
if you can think of interesting, time-saving workflows.
