#+TITLE: Pattern-Matching-With-pcase
#+URL: http://newartisans.com/2016/01/pattern-matching-with-pcase/                                          
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-02 二 09:24]
#+OPTIONS: ^:{}

这是一篇关于如何使用pcase宏的指南.

* 精确匹配

任何数据都准从某种模式. 最精确的模式就是描述要匹配的数据它自己. 让我们看下面这个例子:

#+BEGIN_SRC emacs-lisp
  '(1 2 (4 . 5) "Hello")
#+END_SRC

上面这个例子明确指明了这是一个由4元素组成的list, 其中前两个元素分别是数字1和2; 第三个元素是一个cons cell,它的car是4,cdr是5; 第四个元素则是字符串"Hello". 
这是一个很明确的模式,我们可以直接用它来作相等测试(equality test):

#+BEGIN_SRC emacs-lisp
  (equal value '(1 2 (4 . 5) "Hello"))
#+END_SRC

* 模式匹配

模式只有通用一点的才有用. 假设我们想作一个类似的相等性测试,但是我们不关心最后一个字符串的内容是什么,只要它是字符串就行. 虽然这是一个很简单的模式声明,但是要用相等性测试来实现确很困难.

#+BEGIN_SRC emacs-lisp
  (and (equal (subseq value 0 3) '(1 2 (4 .5)))
       (stringp (nth 3 value)))
#+END_SRC

我们希望能有一种更直观的方法来描述我们想要匹配的那些值. 就好像我们用自然语言那么描述一样的:前三个元素要一模一样,最后一个元素可以是任意字符串. 借助`pcase`我们也能这样表示:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 (4 . 5) ,(pred stringp))
     (message "It matched!")))
#+END_SRC

可以把pcase看成是某种cond语句,只不过匹配条件不是测试是否为非nil,而是将值与一系列的模式进行匹配. 跟cond一样,若有多个模式都能匹配,则只触发第一个匹配模式的语句.

* 捕获匹配的值

But pcase can go one step further: Not only can we compare a candidate value against a family of possible
values described by their pattern, we can also “capture” sub-values from that pattern for later use.
Continuing from the last example, let’s say we want to print the string that match, even though we didn’t care
about the contents of the string for the sake of the match:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 (4 . 5) ,(and (pred stringp) foo))
     (message "It matched, and the string was %s" foo)))
#+END_SRC

Whenever a naked symbol like foo occurs as a logical pattern (see next section), the part of the value being
matched at that position is bound to a local variable of the same name.

* Logical and literal patterns

To master pcase, there are two types of patterns you must know: Logical patterns, and literal, or quoted,
patterns. Logical patterns describe the kind of data we’d like to match against, and other special actions to
take when it matches; and quoted patterns are the “literal” aspect, stating the exact form of a particular
match.

Literal patterns are by far the easiest to think about. To match against any atom, string, or list of the
same, the corresponding literal pattern is that exact value. So the literal pattern "foo" matches the string
"foo", 1 matches the atom 1, etc.

pcase matches against a list of logical patterns, so to use a literal pattern, we must quote it, unless it
consists entirely of self-quoting atoms:

#+BEGIN_SRC emacs-lisp
  (pcase value
    ('sym (message "Matched the symbol `sym'"))
    ((1 2) (message "Matched the list (1 2)")))
#+END_SRC

Literal patterns may also be introduced using a backquote, in which case commas may be used to place logical
patterns within them, in exactly the same way that quoting and anti-quoting works for macros. For example:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,(or 3 4))
     (message "Matched either the list (1 2 3) or (1 2 4)")))
#+END_SRC

* More on logical patterns

There are many special logical patterns. Let’s consider them one by one.

** Underscore _

To match against anything whatsoever, no matter its type or value, use underscore. Thus to match against a
list containing anything at all at its head, we’d use:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(,_ 1 2)
     (message "Matched a list of anything followed by (2 3)")))
#+END_SRC

** Symbol

When performing a match, if a symbol occurs within a logical pattern, it binds whatever was found at that
position to a local symbol of the same name. Some examples will help to make this clearer:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,foo 3)
     (message "Matched 1, 2, something now bound to foo, and 3"))
    (foo
     (message "Match anything at all, and bind it to foo!"))
    (`(,the-car . ,the-cdr))
    (message "Match any cons cell, binding the car and cdr locally"))
#+END_SRC

The reason for doing this is two-fold: Either to refer to a previous match later in the pattern (where it is
compared using eq), or to make use of a matched value within the related code block:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,foo ,foo 3)
     (message "Matched (1 2 %s %s 3)" foo)))
#+END_SRC

** (or PAT ...) and (and PAT ...)

We can express boolean logic within a pattern match using the or and and Patterns:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,(or 3 4)
         ,(and (pred stringp)
               (pred (string> "aaa"))
               (pred (lambda (x) (> (length x) 10)))))
     (message "Matched 1, 2, 3 or 4, and a long string "
              "that is lexically greater than 'aaa'")))
#+END_SRC

** pred predicates

Arbitrary predicates can be applied to matched elements, where the predicate will be passed the object that
matched. As in the previous example, lambdas can be used to form arbitrarily complex predicates, with their
own logic. See above for examples.

** guard expressions

At any point within a match, you may assert that something is true by inserting a guard. This might consult
some other variable to confirm the validity of a pattern at a given time, or it might reference a local symbol
that was earlier bound by the match itself, as described above:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,foo ,(guard (and (not (numberp foo)) (/= foo 10)))
         (message "Matched 1, 2, anything, and then anything again, "
                  "but only if the first anything wasn't the number 10"))))
#+END_SRC

Note that in this example, the guard occurs at a match position, so even though the guard doesn’t refer to
what is being matched, if it passes, then whatever occurs at that position (the fourth element of the list),
would be an unnamed successful matched. This is rather bad form, so we can be more explicit about the logic
here:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,(and foo (guard (and (not (numberp foo)) (/= foo 10)))) _)
     (message "Matched 1, 2, anything, and then anything again, "
              "but only if the first anything wasn't the number 10"))))
#+END_SRC

This means the same, but associates the guard with the value it tests, and makes it clear that we don’t care
what the fourth element is, only that it exists.

** Pattern let bindings

Within a pattern we can match sub-patterns, using a special form of let that has a meaning specific to
`pcase’:

#+BEGIN_SRC emacs-lisp
  (pcase value
    (`(1 2 ,(and foo (let 3 foo)))
     (message "A weird way of matching (1 2 3)")))
#+END_SRC

This example is a bit contrived, but it allows us to build up complex guard patterns that might match against
values captured elsewhere in the surrounding code:

#+BEGIN_SRC emacs-lisp
  (pcase value1
    (`(1 2 ,foo)
     (pcase value2
       (`(1 2 ,(and (let (or 3 4) foo) bar))
        (message "A nested pcase depends on the results of the first")))))
#+END_SRC

Here the third value of value2 – which must be a list of exactly three elements, starting with 1 and 2 – is
being bound to the local variable bar, but only if foo was a 3 or 4. There are many other ways this logic
could be expressed, but this gives you a test of how flexibly you can introduce arbitrary pattern matching of
other values within any logical pattern.

** pcase-let and pcase-let*

That’s all there is to know about pcase! The other two utilities you might like to use are pcase-let and
pcase-let*, which do similar things to their logical pattern counter-part let, but as regular Lisp forms:

#+BEGIN_SRC emacs-lisp
  (pcase-let ((`(1 2 ,foo) value1)
              (`(3 4 ,bar) value2))
    (message "value1 is a list of (1 2 %s); value2 ends with %s"
             foo bar))
#+END_SRC

Note that pcase-let does not fail, and always executes the correspond forms unless there is a type error. That
is, value1 above is not required to fit the form of the match exactly. Rather, every binding that can paired
is bound to its corresponding element, but every binding that cannot is bound to nil:

#+BEGIN_SRC emacs-lisp
  (pcase-let ((`(1 2 ,foo) '(10)))
    (message "foo = %s" foo))   => prints "foo = nil"

  (pcase-let ((`(1 2 ,foo) 10))
    (message "foo = %s" foo))   => Lisp error, 10 is not a list

  (pcase-let ((`(1 2 ,foo) '(3 4 10)))
    (message "foo = %s" foo))   => prints "foo = 10"
#+END_SRC

Thus, pcase-let can be thought of as a more expressive form of destructuring-bind.

The pcase-let* variant, like let*, allows you to reference bound local symbols from prior matches.

#+BEGIN_SRC emacs-lisp
  (pcase-let* ((`(1 2 ,foo) '(1 2 3))
               (`(3 4 ,bar) (list 3 4 foo)))
    (message "foo = %s, bar = %s" foo bar))  => foo = 3, bar = 3
#+END_SRC

However, if you name a symbol with same name in a later logical pattern, it is not used as an eq test, but
rather shadows that symbol:

#+BEGIN_SRC emacs-lisp
  (pcase-let* ((`(1 2 ,foo) '(1 2 3))
               (`(3 4 ,foo) '(3 4 5)))
    (message "1 2 %s" foo))
#+END_SRC

This prints out "1 2 5", rather than the current match.
