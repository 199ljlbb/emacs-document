#+TITLE: From-Vim-to-Emacs+Evil-chaotic-migration-guide
#+URL: http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/                
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-07-28 四 17:26]
#+OPTIONS: ^:{}

我用Vim已经有18年的历史了, 它是我唯一的正式编辑工具(当我编程或写作时使用的工具). 我是如此的痴迷于带模式的编辑方式，以至于当我要用非模式编辑器时会觉得很不习惯. 
你可能会说，编程不是你打字速度快就行了. 这当然没错,但你可以想象一下在平板上用屏幕上键盘来编程的感觉,这差不多就是模式编辑器用户用非模式编辑器时的感觉.

就如同很多Vim用户一样,我也一直对Emacs感到好奇(Emacs是Vim在编辑器世界中的对手!). 它试图在一个窗口中完成所有事情,并且基于一个Lisp虚拟机.
然而它并不支持模式编辑,或者即使有些mode支持模式编辑也远远不如Vim来的好用,这使得我对Emacs敬而远之.

不过现在Evil-mode出现了. 它完美的模拟了Vim. Evil-mode的开发者公开宣称Evil-mode应该与Vim一模一样,任何不一样的地方都视为BUG.
Evil-mode的风评一直不错, 然后有一些相熟的资深Vim党也开始用这个Evil-mode,于是我知道了,这个mode确实很棒.

于是,两周前,我安装了Emacs和Evil开始安装我希望的样子配置Emacs. 我的首要目标是把编辑环境配置成我在Vim中那样的高效. 它们需要有相同的插件和相同的快捷键.
我本以为这个过程会很费时间,因为我听说Emacs的插件要比Vim的少. 而且我也以为用Elisp作配置是很痛苦的一件事情. 然而经过两个星期的折腾,我发现我错了,而且错的很离谱. 
我不仅拥有了之前Vim的几乎所有功能,而且有些地方还更胜之前了(我还尚未开始学习大名鼎鼎的Org mode和Gnus呢).

本文记录了我将Emacs配置成像Vim并再次基础上做出改进的点点滴滴. 大多数的内容都是解释配置文件中的Elisp代码或者关于某个插件的说明.
我希望本文能够帮助其他想尝试Emacs+Evil的Vim资深用户,毕竟当初我在尝试作迁移时那是相当的希望有这么一篇文章可供参考啊.

本文的内容参考了许多人的配置,文章,解答(大多数是StackOverflow上的解答),github以及各种论坛上的内容. 不过为了让文章看起来整洁一些,我就不一一列出这些代码片段的来源了,你可以很容易的在google上搜索到它.

你也可以参照我的 [[http://github.com/juanjux/emacs-dotfiles][Emacs配置]] , 不过要留意,由于我还是个新手因此可能会犯下很多愚蠢的错误.
你也许会发现我把配置拆分成了几个文件. 不过我不建议你一开始就这么做. 将所有配置都放在一个 =.emacs= 中会让你更容易调试(如果你像我一样,你会化很长时间来调试你的配置).
当你的配置差不多定型后,再把它拆分成几类就比较好了.
对了,别忘了先把Vim准备好,你可能会经常要用它来修复那些配错的配置文件.

* A good Windows version

我的工作环境用的是Windows操作系统,但是官方版本的Windows Emacs有很多问题(又慢又不稳定还巨费内存). Reddit用户tuhdo推荐了我两款第三方编译的Windows Emacs. 经过测试,我认为 [[http://emacsbinw64.sourceforge.net/][这款Emacs]] 能够很好的解决那些问题.

* Basic Emacs survival keys

若你是Vim用户,那么安装完Evil后,你可以在大多数情况下都使用Vim风格的操作,但是在你安装Evil时或处于某些Evil不起作用的mode时,你依然需要使用一些基本的Emacs操作. 

+ C-g (即同时按下Control和g键) 能够取消命令提示. 后面我们会将escape键也映射成该操作以符合Vim的操作惯例.
+ C-x k 杀掉(关闭)一个buffer. 那些自动打开的windows通常可以通过按下"q"键来关闭.
+ C-x o (字母"o"而不是数字零) 会在window之间循环跳转.
+ C-x 2 横向分割(window)
+ C-x 3 竖向分割
+ M-x (M = PC上的Alt键) 会显示一个"minibuffer",在那你可以调用Emacs函数. 后面我会展示如何让它更好用.
+ 要切换long lines wrapping功能 (类似Vim中:set wrap/nowrap), 执行 =M-x visual-line-mode RET=.
+ C-y: yank/paste. 粘贴,它在你开启Evil功能时依然有效.

* Package management

Emacs内置的插件(然Emacs的说法叫做package)管理器就很棒. 你可以很方便的用它来显示,下载,升级,安装package.
我试过几乎所有的Vim插件管理器,没有一款跟这个类似的. 你可以通过 =M-x list-packages= 来调用它(然后enter表示安装,d表示删除,x表示执行删除).

下面的配置可以为package管理器添加更多的源,并且还定义了一个函数来安装并加载package(当你需要在不同电脑之前迁移配置时很有用):

#+BEGIN_SRC emacs-lisp
  ;; packages
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")
                           ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")))
  (package-initialize)

  (defun require-package (package)
    (setq-default highlight-tabs t)
    "Install given PACKAGE."
    (unless (package-installed-p package)
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))
#+END_SRC

Note: 若Phil在评论所说, 使用non-stable Melpa仓库对新手来说比较危险,因为它是直接从git master中拉取的源代码,所以在上例中我用的是 melpa-stable 仓库,不过如果你想要使用 Melpa 仓库,你只需要删除配置中名称与URL中的"-stable"就可以了.

* Evil (Vim emulation)

这个package真TMD太棒了. 它支持Vims所有的text command, operator, motion 以及 work flow. 
它几乎模拟了Vim的一切,包括Marks, paragraph reformatting, visual mode, visual block, macros, registers, text objects, splits (可以横向切分也可以纵向切分) :normal, folding等等功能.

当然它不支持直接使用Vim插件,不过有大量的Emacs/Evil的插件可供替代.

* Themes

你可以使用 =M-x load-theme RET= 来选择那些可用主题(你也可以通过package管理器来安装更多的主题).
一旦你选中了要用哪一款主题,可以在 =.emacs= 文件中添加类似这么一行配置: ~(load-theme 'misterioso t)~.

* Terminal Colors

大多数Emacs主题在终端环境(使用emacs -nw会在终端环境下运行emacs)下都很糟糕. Vim下也有一些主题会这样,Emacs的情况要严重得多,几乎所有的主题都有这个问题.
不过这种情况可以通过安装 =color-theme-approximate= 这个package得到有效改善. 这个package的功能类似Vim中的CSApprox: 它会将色彩转换为终端下的等价色.
安装好 =color-theme-approximate= 后,再将 ~(color-theme-approximate-on)~ 添加到你的 =.emacs= 文件中就行了. 
如果没有生效的话,试着把这一行的位置放后一点再试试(我就遇到过这个问题). 
如果完成上面操作后,主题还是惨不忍睹,那你可能就需要检查一下TERM环境变量是否设置正常了.(hint: 该环境变量的值在screen和tmux下是不一样的).

* Change cursor color depending on mode

我在Vim中就喜欢这么干. 好在Emacs也支持这样作. 美中不足的是,在非GUI emacs中似乎做不到这一点.

#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-cursor '("red" box))
  (setq evil-normal-state-cursor '("green" box))
  (setq evil-visual-state-cursor '("orange" box))
  (setq evil-insert-state-cursor '("red" bar))
  (setq evil-replace-state-cursor '("red" bar))
  (setq evil-operator-state-cursor '("red" hollow))
#+END_SRC

* Tabs(标签页)

若你安装了 =evil-tabs= package并通过 ~(global-evil-tabs-mode t)~ 开启该功能,你就拥有了 =:tabnew=, =gt= 等与numbered tabs(编号过的标签页)有关的功能.
若你能像Vim那样通过 =#gt= (这里#表示从0到9的整数) 来切换到指定编号的标签页,那么显示标签页的编号就很有用了. 可惜的是,该package似乎并不支持 =#gt=. 不过我还是用我无上的Elisp能力(接近于0)实现了类似的功能:

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
  (define-key evil-normal-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
  (define-key evil-normal-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
  (define-key evil-normal-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
  (define-key evil-normal-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
  (define-key evil-normal-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
  (define-key evil-normal-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
  (define-key evil-normal-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
  (define-key evil-normal-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
  (define-key evil-normal-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
  (define-key evil-normal-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
  (define-key evil-insert-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
  (define-key evil-insert-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
  (define-key evil-insert-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
  (define-key evil-insert-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
  (define-key evil-insert-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
  (define-key evil-insert-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
  (define-key evil-insert-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
  (define-key evil-insert-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
  (define-key evil-insert-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
  (define-key evil-insert-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
  (define-key evil-insert-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
#+END_SRC

跪求大神帮忙把这坨代码改的更简洁些, 不过不管怎样,这段代码确实可以工作(而且它比按 =#gt= 还少一个键呢).

* Leader key

你需要安装 =evil-leader= 才能自定义 <leader> key. 安装好后,将下面几行写到 =.emacs= 文件中(我这里用逗号作为leader key):

#+BEGIN_SRC emacs-lisp
  (global-evil-leader-mode)
  (evil-leader/set-leader ",")
#+END_SRC

所有我又发现光这样的话,在某些mode中(比如编辑 .emacs 文件时所处于的emacs-lisp-mode),leader key并不起作用,还在该package的FAQ中有该问题的解决方案,你需要在设置 =global-evil-leader-mode= 之前添加一行:

#+BEGIN_SRC emacs-lisp
  (setq evil-leader/in-all-states 1)
#+END_SRC

* Sessions (:mksession in Vim)

Emacs通过命令 =M-x desktop-save= 和 =desktop-read= 来保存/回复编辑环境. 若你想让Emacs自动帮你保存/回复编辑环境,可以将 ~(desktop-save-mode 1)~ 添加到 =.emacs= 文件中.
之后若你想启动emacs而不加载session,则需要通过 =emacs --no-desktop= 来启动emacs. 可惜Emacs sessions 并无法保存elscreens(evil-tabs用它来创建类似Vim那样的标签页)的信息.
若你希望能保存/恢复所有的session信息,包括标签页信息,那么拷贝下面这些函数到你的配置文件中然后为它们分配个快捷键吧:

#+BEGIN_SRC emacs-lisp
  ;; Save session including tabs
  ;; http://stackoverflow.com/questions/22445670/save-and-restore-elscreen-tabs-and-split-frames
  (defun session-save ()
      "Store the elscreen tab configuration."
      (interactive)
      (if (desktop-save emacs-configuration-directory)
          (with-temp-file elscreen-tab-configuration-store-filename
              (insert (prin1-to-string (elscreen-get-screen-to-name-alist))))))

  ;; Load session including tabs
  (defun session-load ()
      "Restore the elscreen tab configuration."
      (interactive)
      (if (desktop-read)
          (let ((screens (reverse
                          (read
                           (with-temp-buffer
                            (insert-file-contents elscreen-tab-configuration-store-filename)
                            (buffer-string))))))
              (while screens
                  (setq screen (car (car screens)))
                  (setq buffers (split-string (cdr (car screens)) ":"))
                  (if (eq screen 0)
                      (switch-to-buffer (car buffers))
                      (elscreen-find-and-goto-by-buffer (car buffers) t t))
                  (while (cdr buffers)
                      (switch-to-buffer-other-window (car (cdr buffers)))
                      (setq buffers (cdr buffers)))
                  (setq screens (cdr screens))))))
#+END_SRC

* Accents

Accents 只在text模式下有效,而在GUI模式下无效. 不过可以通过在 =.emacs= 中添加一行 ~(require 'iso-transl)~ 来解决这个问题.

* "After" macro definition

我从某人的配置中(忘了是谁了,抱歉)拷贝了一个名为"after"的宏,它可以指定加载某些插件后自动运行一段特定的代码. 其定义如下:

#+BEGIN_SRC emacs-lisp
  ;; "after" macro definition
  (if (fboundp 'with-eval-after-load)
      (defmacro after (feature &rest; body)
                               "After FEATURE is loaded, evaluate BODY."
                               (declare (indent defun))
                               `(with-eval-after-load ,feature ,@body))
        (defmacro after (feature &rest; body)
                                 "After FEATURE is loaded, evaluate BODY."
                                 (declare (indent defun))
                                 `(eval-after-load ,feature
                                    '(progn ,@body))))))
#+END_SRC

* Vim-like search highlighting

I prefer how Vim's highlight search and left the highlighted terms until you make another search or clean the
highlighted terms. I tough this would be easy to get but it turned it wasn't so easy (for me). At the end I
made my first Emacs extension (and the first time I've programmed in Lisp since the university a long time
ago...) so all turned well. [[https://github.com/juanjux/evil-search-highlight-persist][The extension]] is already on Melpa has the very brief name of
evil-search-highlight-persist. You can enable it with:

#+BEGIN_SRC emacs-lisp
  (require 'evil-search-highlight-persist)
  (global-evil-search-highlight-persist t)
#+END_SRC

To map a shortcut (leader-space) to clear the highlights I have:

#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key "SPC" 'evil-search-highlight-persist-remove-all)
#+END_SRC

I must note that another good way to search in Emacs is to use occur or helm-occur. This will show the search
results on a list (on a split window with occur) and you'll be able to jump easily to any match.

* Helm: Unite/CtrlP style fuzzy file/buffer/anything searcher on steroids

Helm does the same thing as Unite/CtrlP on Vim and does it really well. You can also enable Helm to manage the
command buffer, which is pretty awesome with: (helm-mode 1) in the .emacs file. I also configured a shortcut
in normal mode, SPACE SPACE which is the same I was using with Vim. This can be done with: (define-key
evil-normal-state-map " " 'helm-mini).

But Helm can be really configurable and you can include or exclude modules in the helm interface show with the
shortcut associated to your config, for example I've:

#+BEGIN_SRC emacs-lisp
  ;; helm settings (TAB in helm window for actions over selected items,
  ;; C-SPC to select items)
  (require 'helm-config)
  (require 'helm-misc)
  (require 'helm-projectile)
  (require 'helm-locate)
  (setq helm-quick-update t)
  (setq helm-bookmark-show-location t)
  (setq helm-buffers-fuzzy-matching t)

  (after 'projectile
         (package 'helm-projectile))
  (global-set-key (kbd "M-x") 'helm-M-x)

  (defun helm-my-buffers ()
    (interactive)
    (let ((helm-ff-transformer-show-only-basename nil))
      (helm-other-buffer '(helm-c-source-buffers-list
                           helm-c-source-elscreen
                           helm-c-source-projectile-files-list
                           helm-c-source-ctags
                           helm-c-source-recentf
                           helm-c-source-locate)
                         "*helm-my-buffers*")))
#+END_SRC

Here, I define a "helm-my-buffers" function that when called (assign a shortcut to it!) will show Helm
interface but searching (fuzzy, real time as you write, unordered) in open buffers, recent files, project
files (see below for more on that), tags inside the files, tabs and results from the Linux command locate that
searches quickly from a database of all the files in the file system. How awesome is that?

But this is only the tip of the iceberg of Helm power. There are sources for searching the symbols (functions,
classes, globals, etc) in the current buffer (helm-imenu), bookmarks (including Chrome/Firefox bookmarks),
HTML colors (showing the color, name, and hexadecimal code), apt packages and more.

If you check the sources of the helm-my-buffers function above you can see that I'm also using
helm-c-source-projectile-files-list. This will use another installable third party package called Projectile
that will search for a git/hg/svn file in the current directory and its parents and extract the current
project files. Linking it will Helm makes it super easy to open any file in your current project (providing
you've it under version control) without having the browse the filesystem, even for files that you have never
opened (and thus are not in Emacs' recent files list).

Another good combination of Helm with a nice Emacs feature (this time included by default) is helm-imenu.
iMenu is a pretty smart minor mode that extract "locations" inside a buffer. For code in a programming
language this will be typically the classes, methods and other symbols. Calling helm-imenu instead of the
default imenu will make it very easy to jump quickly to a location inside the buffer just writing a couple of
letters.

Another great feature of Helm is the chance to replace the default "M-x" menu interface. M-x is what you use
to issue Emacs commands, a little like ":" in Vim (but only a little, ex mode in Vim or Evil is another kind
of animal). One great thing about Emacs is that it has commands and modes for a lot of things, and with Helm
M-x you don't have to learn them all. For example if I don't remember how to show white space characters I
just press M-x and start to write whitesp... and Helm will show me as first result whitespace-mode which is
exactly what I want (it also showed whitespace-cleanup that clears all the trailing whitespace and that is how
I discovered it). Want to check the commands related to spelling? M-x spell. How to list errors in the code
with flycheck? M-x fly errors. How to sort the lines of a selection? M-x sort. This is really convenient and
as an Emacs newbie I get a lot of things done just searching in Helm-M-x without having to search on Google.
You can map Helm-M-x to M-x with:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

There is another package that also helps when learning to use a specific mode, it's called "Discover My Major"
(discover-my-major in Melpa). Invoking the command with the same name will show all the functions enabled by
the current major mode. It's great to discover what every mode can do.

There is another package that also helps when learning to use a specific mode, it's called "Discover My Major"
(discover-my-major in Melpa). Invoking the command with the same name will show all the functions enabled by
the current major mode. It's great to discover what every mode can do.

Edit: thanks to tuhdo in the comments who told me how to show the full path of the files in the helm-recentf
sources).

* Vim's Marks => Evil's Marks + Emacs' Bookmarks

Evil has marks just like Vim: m to jump to a mark, m-letter to set a mark, m-uppercase_letter to set a mark
that works between buffers. But while marks are pretty useful for example to quickly jump between two or three
positions inside some files when you're coding, Emacs also has the concept of "bookmarks" that are like
inter-file marks that you can set with a name (instead of a letter) and that with the elisp bit below in your
config file can be saved between sessions. I'm using helm-bookmarks to see and set them, which I've mapped to
SPC-b. To delete bookmarks, press TAB inside the helm sub-window to see the list of actions and choose "Delete
Bookmark(s)".

#+BEGIN_SRC emacs-lisp
  ;; save bookmarks
  (setq bookmark-default-file "~/.emacs.d/bookmarks"
        bookmark-save-flag 1) ;; save after every change
#+END_SRC

* Folding... and narrowing!

Folding with Evil works as expected, using the same operators that in Vim (with the added benefit that if
you're using Helm-M-x you can do M-x RET fold to search the folding commands in case you forgot the Vim-style
operator). Emacs also support an interesting feature called "narrowing". Narrowing will hide everything else
in the file except the narrowed function or region. This is pretty useful when you want to make global
replaces or run some macro but don't want to affect the other parts of the buffer. I don't use it much so I
haven't assigned any shortcut, I just use the commands narrow-to-region and narrow-to-defun. Once you have
finished working on the narrowed region, you can display the rest of the buffer again with the widen command.

* Project Management

I've already mentioned Projectile that combined with Helm makes searching for project files very convenient,
but there are other options. One of them is project-explorer, which is pretty much like Vim "project" script:
when you enable it it will show a side split (sorry, window) with your project files. With Helm +
Helm-Projectile + the file explorer it's rarely needed but from time to time it's nice to have a tree view of
a source code project (more if the code isn't yours). The Windows can be opened with the command
"project-explorer-open" (I didn't assign any shortcut to it). One thing to note if you're using Evil is that
the shortcuts like TAB to toggle a folder subtree only work if you're in insert mode.

#+BEGIN_SRC emacs-lisp
  (package 'project-explorer)
  (after 'project-explorer
         (setq pe/cache-directory "~/.emacs.d/cache/project_explorer")
         (setq pe/omit-regex (concat pe/omit-regex "\\|single_emails")))
#+END_SRC

* Ctags => Etags

Emacs use a tags file format with a syntax that is different from the "default" ctags called "etags".
Generating etags is easy since Exuberant-Ctags already know how to generate them (just add a -e switch). Emacs
distributions usually came with an etags binary (I'm using ctags because there is a patched version with
support for the [[http://dlang.org][D language]] but Emacs's etag binary doesn't support it). Once generated Emacs will ask you
where the tags file is the first time you use any tag command (like find-tag or evil-jump-to-tag to jump to
the specified tag) and once loaded it will remember it (at least for the current session, I still need to find
how to make it remember the path between sessions).

I've defined this create-tags function on my .emacs to regenerate the tags files (it will ask for a directory
and then use that directory as root from where to scan and place to store the tags file):

#+BEGIN_SRC emacs-lisp
  ;; etags
  (cond ((eq system-type 'windows-nt)
         (setq path-to-ctags "C:/installs/gnuglobal/bin/ctags.exe")))
  (cond ((eq system-type 'gnu/linux)
         (setq path-to-ctags "/usr/local/bin/ctags")))

  (defun create-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    ;; (message
    ;;  (format "%s -f %s/tags -eR %s"
    path-to-ctags (directory-file-name dir-name) (directory-file-name
                                                  dir-name)))
  (shell-command
   (format "%s -f %s/tags -eR %s" path-to-ctags
           (directory-file-name dir-name) (directory-file-name dir-name)))
  )
#+END_SRC

With third party packages there is also support for normal ctags files and GNU Global, but I find the etags
support more than convenient for my needs

* Spell checking

No need to install anything if you have ispell on your system, just do: :ispell-buffer to start a spell check
of the current buffer (alternatives are show above and shortcuts below) and :ispell-change-dictionary to use
another dictionary (to check another language). If you prefer spell checking on the fly with underlines under
misspelled words use :flyspell-mode and to see alternatives to a misspelled word press M-$ (Alt-$ on most PCs)
with the cursor over the word.

* Relative line numbers

Install the package "relative-line-numbers" and enable it globally on your config file with:

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'relative-line-numbers-mode t)
  (add-hook 'prog-mode-hook 'line-number-mode t)
  (add-hook 'prog-mode-hook 'column-number-mode t)
#+END_SRC

* Easymotion => Evil Ace Jump

The functionality provided by the awesome Easymotion plugin on Vim is actually integrated by default on Evil
since it incorporates a package called Ace Jump that does mostly the same. It's less powerful than Easymotion
(some jumps like backwards-only / forward-only / end-of-word and others are missing) and I prefer how
Easymotion shows directly two chars when a jump is going to require them (instead of showing one and after
pressing it, the other which is what Ace-Jump does) but the important modes (bidirectional jump to word and to
char) that were the ones I was mostly using are provided.

Unlike Easymotion, jump to word asks for a letter, but that can be easily disabled with: (setq
ace-jump-word-mode-use-query-char nil). The author makes the case that without asking for a char you're
probably entering more key presses most of the time. This is probably true, but when I want to jump to a
random word inside the buffer my brain-eye connection has already identified the word but I've to stop and
look/think for the first char, so in the end for me is actually faster to get jump shortcuts to all the words
without having to provide the leading character.

I mapped the word/line/char to e/l/x with:

#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key "e" 'evil-ace-jump-word-mode) ; ,e for Ace Jump (word)
  (evil-leader/set-key "l" 'evil-ace-jump-line-mode) ; ,l for Ace Jump (line)
  (evil-leader/set-key "x" 'evil-ace-jump-char-mode) ; ,x for Ace Jump (char)
#+END_SRC

* Smooth scrolling

One annoying thing that most Vim users will find in Emacs is the jumpy scrolling. To have Emacs scroll like
Vim (that is, line by line and leaving some lines before starting to scroll) the solution is to install the
package smooth-scrolling and add this to your config:

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 5
        scroll-conservatively 9999
        scroll-step 1)
#+END_SRC

It's not perfect because sometimes when you're close to the start of end of the file it still jumps.

* Powerline

Super-easy, just install the powerline-evil package and put this in your config:

#+BEGIN_SRC emacs-lisp
  (require 'powerline)
  (powerline-evil-vim-color-theme)
  (display-time-mode t)
#+END_SRC

* Syntactic checking on the fly with Flycheck

One of the best Vim plugins if you're a programmer is Syntastic that runs a syntactic check auto detecting a
huge variety of linters every time you save. Emacs also have a similar package called "Flycheck". It is even
better because it runs in parallel while you work so you don't have to wait for it to finish its checks like
happens with Vim. Another related package is flycheck-pos-tip that shows errors on a tooltip (if you're on GUI
Emacs, obviously) instead of the minibuffer. My full flycheck config is:

#+BEGIN_SRC emacs-lisp
  ;; flycheck
  (package 'flycheck)
  (add-hook 'after-init-hook #'global-flycheck-mode)

  (after 'flycheck
         (setq flycheck-check-syntax-automatically '(save mode-enabled))
         (setq flycheck-checkers (delq 'emacs-lisp-checkdoc flycheck-checkers))
         (setq flycheck-checkers (delq 'html-tidy flycheck-checkers))
         (setq flycheck-standard-error-navigation nil))

  (global-flycheck-mode t)

  ;; flycheck errors on a tooltip (doesnt work on console)
  (when (display-graphic-p (selected-frame))
    (eval-after-load 'flycheck
      '(custom-set-variables
        '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages))))
#+END_SRC

* j/k for browsing wrapped lines

Evil has the same problem as Vim when browsing with j/k long wrapped lines; it jumps the entire "real" line
instead of the visual line. The solution is also easy:

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+END_SRC

* escape... escapes things

One very annoying thing with Emacs is that when you are in the M-x buffer (the one were you call Emacs
functions) you've to use C-g to exit it. If you use escape as most Vim users would tend to do by default you
need to hit the key like a million times (it's more like 3, but it's extremely frustrating anyway). This code
on my .emacs that I copied from [[https://github.com/davvil/.emacs.d/blob/master/init.el][davvil init.el on Github]] fixed it:

#+BEGIN_SRC emacs-lisp
  ;; esc quits
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+END_SRC

* Start maximized, please

Another minor annoyance was that Emacs (GUI) didn't start maximized by default, but this is easy to fix:

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(initial-frame-alist (quote ((fullscreen . maximized))))) ;; start maximized
#+END_SRC

* c-k/c-j for page down/up

One thing that surprised me considering how complete Evil is, is the lack of Vim's Control-d/Control-u for
page down/up. Probably because C-u is pretty important in Emacs (it's the shortcut to give a numeric parameter
to other commands, I think). I've in fact these mapped on my .vimrc to c-k/c-j (because I think they're more
consistent with Vim's j/k movement keys) so that's how I mapped them in Emacs:

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-k") (lambda ()
                                                  (interactive)
                                                  (evil-scroll-up nil)))
  (define-key evil-normal-state-map (kbd "C-j") (lambda ()
                                                  (interactive)
                                                  (evil-scroll-down nil)))
#+END_SRC

* Coding Style and spaces instead of tabs

Emacs by default do the really evil thing of using tab characters for indentation. To do the right thing and
use spaces with 4 spaces per tab: (setq-default tab-width 4 indent-tabs-mode nil). Also, I prefer the "bsd"
style on my code on C-like languages (C, C++, Java, D...) but with 4 spaces tabs instead of 8 so I also added:
(setq-default c-basic-offset 4 c-default-style "bsd").

There is also a nice package called "dtrt-indent" that can automatically determine the indentation settings
used on the file that you're currently editting and adapt Emacs's settings to them. It's great when you're
editing external files not created by you or that for some reason follow different indentation rules that the
ones you've in your config file.

#+BEGIN_SRC emacs-lisp
  (package 'dtrt-indent)
  (dtrt-indent-mode 1)
#+END_SRC

* Auto-indent with the Return key

By default Emacs doesn't indent new lines until you press the TAB key. That is not good. But it can be changed
easily enough to do the Vim thing, adjusting indentation on every new line automatically with:

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

* Show matching paren

If you want to show the matching parenthesis, brace or bracket automatically, add this option:
(show-paren-mode t). You can also install the Autopairs package to automatically add the matching parens/
braces/etc after adding the opening one. I've mixed feelings about it because while very convenient (specially
with Lisp!) it can be also very annoying when you want to surround something with parents and it adds a
useless ")" after the opening one, I should use "Surround" on these cases, but half of the time I forget it.
To enable autopairs put this on your config file after installing the package:

#+BEGIN_SRC emacs-lisp
  (require 'autopair)
  (autopair-global-mode)
#+END_SRC

* Fill column, auto line breaking and column limit mark

To visually mark the configured fill-column for the mode (like the colorcolumn option in Vim) install the
package fill-column-indicator, then you'll enable it on every mode where you want to display it with fci-mode
(see below).

To configure auto line breaking when the line exceed 82 chars for text and markdown files, with fill indicator
line:

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda ()
                              (turn-on-auto-fill)
                              (fci-mode)
                              (set-fill-column 82)))
  (add-hook 'markdown-mode-hook (lambda ()
                                  (turn-on-auto-fill)
                                  (fci-mode)
                                  (set-fill-column 82)))
#+END_SRC

To set the non-auto-line limit for Python a C-mode (and D) to 94:

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook (lambda ()
                                (fci-mode)
                                (set-fill-column 94)))
  (add-hook 'c-mode-hook (lambda ()
                           (fci-mode)
                           (set-fill-column 94)))

  (add-hook 'd-mode-hook (lambda ()
                           (fci-mode)
                           (set-fill-column 94)))
#+END_SRC

* Silver Searcher (ag)

If you don't know it, the Silver Searcher is like Ack but a lot faster. The "ag" package will allow you to
make searches with it without leaving Emacs and show the results in a quickfix-style windows where you can
select results and jump to them: M-x ag RET [search] RET [directory] RET.

* Spanish keyboard remaps

I use Spanish keyboards. Yes, I know, Vim is much better with an English keyboard, but I'm 36 and have been
using the Spanish layouts since I was 8, which means that my brain is too hardwired to it. But with a few
remaps I made my Vim experience much better. These were - (minus sign) in normal mode as / (to search), as
escape in insert mode (I want to try the kj thing) and as :. When you remap keys in Emacs you have to know the
name of the function that the shortcut key will point to. Fortunately using C-h k (Control-h, release, k) will
tell you the name of the function associated with the next key you press, so getting the name of the functions
for these remaps is easy. The / and : remaps were easy:

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map "-" 'evil-search-forward)
  (define-key evil-normal-state-map " " 'evil-ex)
  (define-key evil-insert-state-map " " 'evil-normal-state)
#+END_SRC

* Don't create backup files

I use version control and I'm a compulsive saver, so I don't need backup files. I've these disabled on Vim and
I've also disabled them on Emacs:

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

* Don't move back the cursor one position when exiting insert mode

This is something that I hated in Vim so I had it disabled with the following lines on my .vimrc:

#+BEGIN_EXAMPLE
  autocmd InsertEnter * let CursorColumnI = col('.')
  autocmd CursorMovedI * let CursorColumnI = col('.')
  autocmd InsertLeave * if col('.') != CursorColumnI | call cursor(0, col('.')+1) | endif
#+END_EXAMPLE

To get the same behaviour in Evil you just have to set one option:

#+BEGIN_SRC emacs-lisp
  (setq evil-move-cursor-back nil)
#+END_SRC

* Remember the cursor position of files when reopening them

Pretty easy:

#+BEGIN_SRC emacs-lisp
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq-default save-place t)
  (require 'saveplace)
#+END_SRC

* Disable scroll bars

By default Emacs put a scroll bar on every window (split) which IMO is incredibly ugly. I already have the %
of my position on the file in Powerline so I don't need any scroll bars: (scroll-bar-mode -1).

* "Graphical" GDB

Emacs GDB mode (enabled with M-x gdb RET binary_path) is pretty cool because it create several windows in the
style of typical IDE debuggers, but that's not enabled by default, to enable it: (setq gdb-many-windows t).

Once you're in GDB mode with the binary loaded you can change to the source code windows (use C-x o to switch
between splits or just mouse clicks, Vim-style C-w key bindings doesn't work in gdb mode), load the source
code file you want to set breakpoints on and set a break point with M-x gud-break. Then you can run the
program with "run" (r) on the gdb window and once in the break point advance with next (n) or step (s). Local
vars and registers are show in one window, breakpoints and the stack frame in another one.

* Color Identifiers Mode and Color Delimiters

The plugin colors-identifiers-mode colorize every variable in a different color. I've mixed feelings about it
because the code looks like a fruit salad, but it makes really easy to visually identify where variables are
used. I'm using it for now. Setup is:

#+BEGIN_SRC emacs-lisp
  (package 'color-identifiers-mode)
  (global-color-identifiers-mode)
#+END_SRC

Another firm step into the total fruitsalarization of your Emacs is the Rainbow Delimiters package that will
color nested delimiters on a different color so you can check easily which of them are pairs without having to
move the cursor over them. When you have lots of nested parenthesis this helps a lot to see the pairs without
having to move the cursor over them.

#+BEGIN_SRC emacs-lisp
  (package 'rainbow-delimiters)
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

* Diminish to clean clutter from the modeline

Diminish will remove the minor mode indicators from the mode line (or powerline). Example config:

#+BEGIN_SRC emacs-lisp
  (require 'diminish)
  (diminish 'visual-line-mode)
  (after 'autopair (diminish 'autopair-mode))
  (after 'undo-tree (diminish 'undo-tree-mode))
  (after 'auto-complete (diminish 'auto-complete-mode))
  (after 'projectile (diminish 'projectile-mode))
  (after 'yasnippet (diminish 'yas-minor-mode))
  (after 'guide-key (diminish 'guide-key-mode))
  (after 'eldoc (diminish 'eldoc-mode))
  (after 'smartparens (diminish 'smartparens-mode))
  (after 'company (diminish 'company-mode))
  (after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
  (after 'git-gutter+ (diminish 'git-gutter+-mode))
  (after 'magit (diminish 'magit-auto-revert-mode))
  (after 'hs-minor-mode (diminish 'hs-minor-mode))
  (after 'color-identifiers-mode (diminish 'color-identifiers-mode))
#+END_SRC

* Select last yanked text

This is a pretty useful shotcut I've on my .vimrc that selects the last pasted (yanked) text:

#+BEGIN_EXAMPLE
  nnoremap </leader><leader>V `[v`]
#+END_EXAMPLE

Thanks to the comment by delexi I know that the function in Emacs is called exchange-point-and-markwhich
defaults to C-x C-x but I've remapped to leader-V with:

#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key "V" 'exchange-point-and-mark)
#+END_SRC

* Other Emacs alternatives for popular Vim plugins

  * Powerline => Powerline-Evil
  * Emmet => emmet-mode. I mapped "m" to "emmet-expand-line" because the default C-j shortcut is already
    defined in Evil.
  * Surround => evil-surround (same operators)
  * Tabular.vim => M-x align-regexp RET regexp RET (with a visual selection)
  * Rename => M-x dired-jump, R to rename the file, RET to reopen.
  * jDaddy => I only really used it to prettify json objects, this can be done with the functions defined [[http://irreal.org/blog/?p=354#comment-79015][by]]
    [[http://irreal.org/blog/?p=354#comment-79015][James P.]].
  * Autocomplete and company mode works much like YouCompleteMe on Vim: they give an improved completion when
    you're programming. I don't know the difference between both, Company is newer, I think, but the ac-dcd
    package for completing the D language is for Autocomplete so that's what I'm using.
  * Vimdiff => M-x ediff-files or ediff-buffers. Pretty similar. Press ? for help. If you use Helm (just use
    it) when you're in a helm file list you can press TAB and in the actions list you can select one to
    marking the file for ediff; much quicker than browsing by hand to the files to compare.
  * netrw/nerdtree => M-x dired (included) or M-x dired+ (installable).

* Other random thoughts about Emacs, Evil and Vim

  * Copy and paste with the system clipboard works without having to paste from the "+ or "* register. It's
    still saved on those registers, but also in the default register so if you paste after copying from any
    other desktop program and then paste without specifying any register it will pull that register. Nice.
  * Evil doesn't have :pu/:put (paste below current line).
  * Some windows with Evil (like :registers) use Emacs key binding of q to exit instead of Vim esc.
  * The toolbar is actually useful for a newbie like me. Check it. To use the toolbar without the mouse you've
    the F10 key binding.
  * Paralellization is very nice to have. I love to have my syntax checked without pauses, but...
  * Not everything is perfectly paralellized. For example, when the package manager is loading the information
    from a package on a split (and sometimes it takes its time), all the interface hangs. One nice feature of
    Emacs is that you can almost always cancel any long running process with Control-G.
