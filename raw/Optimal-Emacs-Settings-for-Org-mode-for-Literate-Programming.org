#+TITLE: Optimal-Emacs-Settings-for-Org-mode-for-Literate-Programming
#+URL: http://fgiasson.com/blog/index.php/2016/06/21/optimal-emacs-settings-for-org-mode-for-literate-programming/?utm_content=36384675&utm_medium=social&utm_source=twitter
#+AUTHOR: lujun9972
#+CATEGORY: raw
#+DATE: [2016-08-05 五 12:58]
#+OPTIONS: ^:{}


我一度热衷于用Emacs和Org-mode以文学编程的方式开发来开发Clojure. 我也写过了很多关于文学编程的文章,比如[[http://fgiasson.com/blog/index.php/2016/04/27/my-literal-programming-commitment/][它的基础理念]], [[http://fgiasson.com/blog/index.php/2016/05/30/creating-and-running-unit-tests-directly-in-source-files-with-org-mode/][文学编程的好处]], [[http://fgiasson.com/blog/index.php/2016/06/09/literate-programming-and-team-development/][等]][[http://fgiasson.com/blog/index.php/2016/04/05/using-clojure-in-org-mode-and-implementing-asynchronous-processing/][等]]. 
这一次我想告诉你们我是怎么来实践文学编程的,我在实践过程中总结出来的经验有哪些,我写程序时一般是怎样的结构,等等内容.

不过在我开始之前,我想我有必要先解释一下为了用文学编程开发应用时有一个流畅的体验,我是怎样配置Org-mode的.
再然后才会写一系列的文章来解释我是怎么组织Clojure项目的,我的开发流程等内容.

如果你没有配置过Clojure/Cider, 那我推荐你[[http://fgiasson.com/blog/index.php/2016/06/14/my-optimal-gnu-emacs-settings-for-developing-clojure-revised/][看看这篇文章]], 它会告诉你如何在Emacs中配置Clojure开发环境.

* Packages

[[http://fgiasson.com/blog/index.php/2016/06/14/my-optimal-gnu-emacs-settings-for-developing-clojure-revised/][Emacs安装Cider之后]], 你要做的第一件事就是安装下面这些package. 这些package,有些是使用Org-mode必须的,有些能够优化Org-mode的使用体验.

1. [[http://orgmode.org/][org]]
2. [[https://github.com/emacsmirror/adaptive-wrap][adaptive-wrap]]
3. [[https://www.emacswiki.org/emacs/Htmlize][htmlize]]

安装过程也很容易,运行下面这些命令就行:

#+BEGIN_EXAMPLE
M-x package-install [RET] org [RET]
M-x package-install [RET] adaptive-wrap [RET]
M-x package-install [RET] htmlize [RET]
#+END_EXAMPLE

你也可以先运行 =M-x package-list-packages=, 然后将光标移动到要安装的package那一行. 按下 =i= (意思是install), 等待所有要安装的package都选中后,再按下 =x= (意思是execute) 就可以一次性安装所有的package了.

* Configure Org-mode Editor Behaviors

Org-mode安装之后有很多默认的设置,但是我觉得它的默认设置不适于进行文学编程. 
首先我要隐藏掉一些Org-mode的标志,而代之以显示为它真正要显示的字体样式. 例如,我不想看到 =/test/= 这样的内容,而应该看到的是斜体的 =test=. 同样的,粗体,链接也是一样的显示方式. 为了做到这一点,我们需要设置一下 =org-hide-emphasis-markers= 变量.

然后我会为Org-mode设置开启Emacs visual line mode. 这样就会自动折行而无需手工调整.

#+BEGIN_SRC emacs-lisp
  (require 'org)

  ;; Remove the markup characters, i.e., "/text/" becomes (italized) "text"
  (setq org-hide-emphasis-markers t)

  ;; Turn on visual-line-mode for Org-mode only
  ;; Also install "adaptive-wrap" from elpa
  (add-hook 'org-mode-hook 'turn-on-visual-line-mode)
#+END_SRC

* Configure Cider for Org-mode

由于我们想用文学编程的方式来开发Clojure,因此我们需要配置一下Org-mode让它使用Cider作为Clojure的后端. 
Org-mode的code block功能支持许多的编程语言. 然而除了像Elisp(Elisp本身使用Emacs作为后端)这样的语言外,绝大部分的语言都要有一个后端作支持.
我们要做的就是为Clojure设置一个后端.

这里我们首先要做的是告诉Org-mode要支持哪些语言的code blocks. 我这里暂时只定义了4种语言: clojure, sh, dot 和 elisp.

然后我们要设置 =org-babel-clojure-backend= 为cider.

#+BEGIN_SRC emacs-lisp
  ;; Configure org-mode with Cider

  ;; Configure Org-mode supported languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((clojure . t)
     (sh . t)
     (dot . t)
     (emacs-lisp . t)))

  ;; Use cider as the Clojure execution backend
  (setq org-babel-clojure-backend 'cider)
  (require 'cider)
#+END_SRC

** Useful Key Bindings

Cider本身有一些快捷键如果能直接在Org-mode触发那就很方便了. 要做到这样也不难,只要像下面这样设置就行了. 
我这里设置了两个快捷键,一个用来运行上一个Clojure表达式的,快捷键为 =C-x C-e=. 还有一个是获取symbol的文档说明的,快捷键是 =C-c C-d=

你可能会觉得奇怪为什么要重新设置一下快捷键呢? 这是因为Org-mode的code block本身不是处于Clojure major mode下的, 因此Clojure major mode的快捷键并不能在Org文件中直接使用. 这也就是为什么我们需要在org-mode下重用映射一次快捷键的原因了.

#+BEGIN_SRC emacs-lisp
  ;; Useful keybindings when using Clojure from Org
  (org-defkey org-mode-map "\C-x\C-e" 'cider-eval-last-sexp)
  (org-defkey org-mode-map "\C-c\C-d" 'cider-doc)
#+END_SRC

** Configuration of Custom Features

在我的[[http://fgiasson.com/blog/index.php/2016/04/05/using-clojure-in-org-mode-and-implementing-asynchronous-processing/][Using Clojure in Org-mode and Implementing Asynchronous Processing]] 一文中,我提到了 =org-babel-clojure= 实现的一些限制,也展示了越过这些限制的方法.
这里与那篇文章中设置唯一不同的地方在于我需要去除nrepl中间层的超时设置. 方法如下:

#+BEGIN_SRC emacs-lisp
  ;; No timeout when executing calls on Cider via nrepl
  (setq org-babel-clojure-sync-nrepl-timeout nil)
#+END_SRC

请确保你只有在已经按照上面那篇博文中所提到的方法修改了 =org-bable-clojure= 的情况下才做上面的设置.

* Configure Code blocks Behaviors

Org-mode中的code block有它们独特的行为规范,例如,缩进的空格数量,是否能使用shift+方向键选中文本,是否使用编程语言所属mode的原生tab行为以及语法高亮等等. 对于这些行为规范,我们也能做出改变.

#+BEGIN_SRC emacs-lisp
  ;; Let's have pretty source code blocks
  (setq org-edit-src-content-indentation 0
        org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-confirm-babel-evaluate nil
        org-support-shift-select 'always)
#+END_SRC

* Change Behaviors On Save

将Org-mode配置成文学编程环境最主要的是配置org-mode文档保存时的行为.

使用文学编程的目的是在记录软件开发过程,软件的作用,软件的实现等内容的同时将软件编写出来. 我希望每次保存文件时,都能自动抽取出文件中的代码并保存到相应的Clojure源文件中去. 要做到这一点,需要为 =after-save-hook= 添加一个新的函数, 这个新的函数先判断当前保存的buffer是否是Org-mode的buffer,若是的话,则调用Org-mode的tangle过程.

此外,在实际用文学编程开发Clojure时,你通常还有在另一个buffer中打开tangled的源文件. 这时若你修改了org文件并保存,则buffer中的内容与tangled文件的实际内容就不同步了. 要解决这个问题需要开启 =global-auto-revert-mode=. 它会在buffer所属文件被修改后,自动重新加载文件的内容.

Finally, because Org-mode is not only about code blocks, I also enabled a final behavior when I save a Org
file. What I often do is to leave TODO tasks at different places in my Org file to tell me what some work
needs to be done at that place. However, once you start developing multiple projects with Org-mode, and when
you start using Org-mode for others of its features, there is no way to track where you left TODO items across
your entire computer system (and not just programing projects!). This is why Org-mode created a global list of
TODO items via its agenda feature. To see the list of all the TODOs across all the Org files you created, you
can access it using: M-x org-todo-list. However the problem here is that each of the Org file you want to have
accessible in your agenda, you have to push it to the agenda system. It is not a problem in itself, but it
becomes a problem is you forget to push each relevant Org file to the agenda. This is why I choose to
automatically push any Org file to the Org agenda every time a Org file is being saved. That way I don’t have
to worry when I check the global list of TODOs, I am sure that all of them are there.

#+BEGIN_SRC emacs-lisp
  ;; Tangle Org files when we save them
  (defun tangle-on-save-org-mode-file()
    (when (string= (message "%s" major-mode) "org-mode")
      (org-babel-tangle)))

  (add-hook 'after-save-hook 'tangle-on-save-org-mode-file)

  ;; Enable the auto-revert mode globally. This is quite useful when you have 
  ;; multiple buffers opened that Org-mode can update after tangling.
  ;; All the buffers will be updated with what changed on the disk.
  (global-auto-revert-mode)  

  ;; Add Org files to the agenda when we save them
  (defun to-agenda-on-save-org-mode-file()
    (when (string= (message "%s" major-mode) "org-mode")
      (org-agenda-file-to-front)))

  (add-hook 'after-save-hook 'to-agenda-on-save-org-mode-file)
#+END_SRC

* Export Configurations

There are a few things you can do regarding how you export your org files. One thing I like to do is to set
org-html-htmlize-output-type to css (default is inline-css) such that it does not include the CSS in the
exported HTML. I prefer using the CSS that comes with the HTML themes I use. However, when I need inline CSS
(like when I export HTML to be displayed elsewhere, i.e. on my blog) then I simply define a elisp code block
to set org-html-htmlize-output-type back to inline-css to reverse that behavior for that special usecase.

#+BEGIN_SRC emacs-lisp
  ;; make sure that when we export in HTML, that we don't export with inline css.
  ;; that way the CSS of the HTML theme will be used instead which is better
  (setq org-html-htmlize-output-type 'css)
#+END_SRC

** Enable External Exporters

There are tons of Org-mode export plugins, but not all of them are enabled by default. For contributed
exporters, you will have to get it from the contrib/lisp [[http://orgmode.org/w/org-mode.git?p=org-mode.git;a=tree;f=contrib/lisp;h=c5dc72cebae54e5175f373d5b85f1a6bdbbd764f;hb=refs/heads/master][folder on the Git repository]] and save it in your else
repository in [home]/.emacs.d/elpa/[org-20160623]/ Here is an example of how you can enable a new one which is
the exporter for Confluence. Then you can export typing M-x org-confluence-export-as-confluence

#+BEGIN_SRC emacs-lisp
  ;; Enable Confluence export
  (require 'ox-confluence)
#+END_SRC

* Dire Configuration

I personally use Dire a lot. However it displays everything by default which may not be optional, particularly
when working within Org related directories with all the auto-save files that get generated. This is why I
like to filter out a few things such that everything is not being displayed in the Dire buffer.

#+BEGIN_SRC emacs-lisp
  ; Remove autosave and other unnecessary files to see in Dire
  (require 'dired-x)
  (setq-default dired-omit-files-p t) ; Buffer-local variable
  (setq dired-omit-files "^\\.?#")
#+END_SRC

* Spell checker

It is always convenient to have a spell checker in Org-mode. Right now I am using ispell along with flyspell.
That works fine, but I don’t like the fact that the last aspell version for Windows is about 14 years old! Any
idea to improve this situation would be greatly welcome!

The first step that is required to enable this feature is to download [[http://aspell.net/win32/][GNU Aspell (in my case, for Windows)]].
Then we have to instruct Emacs where the aspell dictionary is located, and then we have to enable Flyspell for
text modes. Finally, make sure to install the appropriate language pack as well.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(ispell-program-name "c:\\Program Files (x86)\\Aspell\\bin\\aspell.exe"))

  ;; Enable Flyspell for text modes
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

* DOT support

[[https://en.wikipedia.org/wiki/DOT_(graph_description_language)][DOT]] is like a markup language for describing graphs. It is really simple to use and generate effective graph
images that can easily be embedded into your Org-mode files.

The first step is to install [[http://www.graphviz.org/][Graphviz]] on your computer. This is the library that will be used to generate the
images from the DOT specification. The only thing you have to do is to make sure that Graphviz’s bin directory
is in the Path environment variable and you are done.

Once Graphviz is installed and configured, restart Emacs and start using it right away, no other configuration
is required. Here is an example of a class hierarchy created using DOT:

#+BEGIN_SRC dot
  digraph {
    soloist -> "musical performer";
    "musical performer" -> musician;
    musician -> artist;
    artist -> person;
    person -> human;
    author -> artist;
    "scifi writer" -> author;
    journalist -> author;
    correspondent -> journalist;
  }
#+END_SRC

[[http://fgiasson.com/blog/wp-content/uploads/2016/06/actors-authors-humans-e1466538581874.jpeg]]

* Inline Images Display

One essential feature of Org-mode to make it a useful Notebook application is to be able to have inline images
(that we generate from code blocks or that are somewhere on the file system) directly in Emacs. Depending on
your Emacs distribution, you may require to download and install a few libraries in order to make this working
properly (at least on Windows).

The first step is to make sure that Org-mode does display inline images by default. If you don’t want this
behavior, you can always use the key binding C-c C-x C-v to toggle this behavior. If you want to enable this
by default when Emacs enter in Org-mode, then you have to add the following to your .emacs file:

#+BEGIN_SRC emacs-lisp
  ;; Enable inline image when entering org-mode
  ;; Make sure you have all the necessary DLL for image display
  ;; Windows ones can be downloaded from: https://sourceforge.net/projects/ezwinports/files/
  (defun turn-on-org-show-all-inline-images ()
    (org-display-inline-images t t))

  (add-hook 'org-mode-hook 'turn-on-org-show-all-inline-images)
#+END_SRC

It is possible that you get the following error message in your mini buffer if you type C-c C-x C-v:

    “no images to display inline”
   
What this probably means is that you are lacking the libraries to display these type of images. What you
should do is to run this elisp code to see the expected library files each supported file format and the
expected library files names:

#+BEGIN_SRC emacs-lisp
  (print image-library-alist)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((xpm "libxpm.dll" "xpm4.dll" "libXpm-nox4.dll") (png "libpng16.dll" "libpng16-16.dll") (tiff "libtiff-5.dll" "libtiff3.dll" "libtiff.dll") (jpeg "libjpeg-9.dll") (gif "libgif-7.dll") (svg "librsvg-2-2.dll") (gdk-pixbuf "libgdk_pixbuf-2.0-0.dll") (glib "libglib-2.0-0.dll") (gobject "libgobject-2.0-0.dll") (gnutls "libgnutls-28.dll" "libgnutls-26.dll") (libxml2 "libxml2-2.dll" "libxml2.dll") (zlib "zlib1.dll" "libz-1.dll"))
#+END_SRC

Then for each of the format you want to report, get the library file and for add it in your [...]/emacs/bin/
folder. On windows, you can find all these DLL from the [[https://sourceforge.net/projects/ezwinports/files/][EzWinPorts]] project repository.

* Language Specific Libraries

For a few tasks I simply use external libraries to get the job done instead of Emacs/Org-mode specific plugins
or functionality. I will refer to Clojure external libraries, but the same kind of libraries could be used in
any other programming languages.

For example, if I want to output tabular information in Org-mode, then I normally use the [[https://github.com/cldwalker/table][Clojure Table]]
application which takes multiple different kind of Clojure data structure and turns them into well-formatted
tables in the resultsets. This is really handy for that kind of operation.

Otherwise I use [[http://incanter.org/][Incanter]] a lot to generate effective graphs, charts of plots that I save as PNG and that I
display inline in Org-mode. However, if I have a graph or flow chart to create, then I will use the DOT plugin
since it is really easy to use not to use it within Org-mode.

Basically anything that output some text or some image could be used within Org-mode, but for the kind of
software I develop and the kind of data analysis tasks I am doing, these are the two bests in my toolset for
the moment.

* Helpful Keys for Working With Org-mode

There are a few key bindings in Org-mode that really make your life easier when come the time to do Literate
Programming in Org-mode.

If you are using Clojure in your Org file, then the first thing to do is to start Cider. I bound cider-jack-in
to F9. Once Cider is started, then you will be able to run Clojure code within your Org file.

The most obvious key binding is C-x C-s which will save the Org file. At the same time, it will do all the
things described in the section Change Behaviors On Save described above.

Then we have C-c C-c that will execute a specific code block and show the results. Note that the cursor needs
to be somewhere within the code block (including the header and footer) to execute that block with that key
binding.

When you open an existing Org file with a lot of code blocks, you often want to run all the code blocks at
once. It can easily be done using C-c C-v t which will do exactly that.

We have to remember that it is not the Clojure major mode that we use directly in Org-mode. However, it is
often handy to be able to switch to Clojure’s major mode from a Org file (to get auto completion, etc.). It
can easily be done with C-c ' which will open a new buffer with the code in Clojure’s major mode. Then if you
modify that buffer and save it using C-c C-x then the Org file will be updated with the changes as well. To
switch back to the Org file, then you simply has to hit C-c ' again.

There are a few key bindings quite handy to work with the structure of the document. We often endup writing
big Org file with a lot of headers and level of headers. It is quite handy to be able to focus on specific
regions in a Org outline. This can easily be done using C-x n s which will focus on a particular region (only
the content of that region appears in the buffer). Then you can use C-x n w to unfocus a focused region
(everything surrounding that region will reappear in the buffer).

There are tens of other key bindings that you will endup using in Org-mode for doing Literate Programming, but
these are the ones I most often use when writing a Org file.

* Conclusion

As you can see, there are quite a lot of things that can be configured in Org-mode. This is even just the tip
of the iceberg in fact. However, these are the main features I use to do Literate Programming and to create
data analysis notebooks. Now that we have [[http://fgiasson.com/blog/index.php/2016/06/14/my-optimal-gnu-emacs-settings-for-developing-clojure-revised/][Emacs configured]], and that we have Org-mode configured, my next step
will be to write about how I do organize my Clojure applications to write Literate programs.
